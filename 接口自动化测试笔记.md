# 简介

## 需要核心掌握的部分：

面向对象：继承和封装（包括类的继承、类的方法、类的封装）

python高级用法：包含列表推导式，匿名函数，三目运算，装饰器，闭包，拆包

函数返回值的处理

Unitttest测试框架和测试套件的的使用

Requests库

精通Postman和Jmeter测试工具(引导开发进行自测，发送测试报告)

# 第一章python基础知识

## 一.python基本方法

注意⚠️:python3.exe是python的解释器，其本质是打开文件，把文件的内容加载到内存中，在内存中的代码执行运行起来后，反馈给终端的用户,python3输入的内容都默认为字符串类型的。

### 1.str的基本方法

```python
'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'
```

```python
name = "沈强"
age = 28
print("我的名字叫{0},我的年龄{1}".format(name,age))
print("我的名字叫%s，我的年龄%d"%(name,age))
print("我的名字叫{name}，我今年{age}岁".format(name=name,age=age))
```

### 2.list的基本方法(列表推导式)

```python
'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'
```

```python
list1 = [1,2,3,4,5,2,3,0,8]
list2 = [3,3,3]
# print(dir(list1))
list1.append(99)
print(list1)
list1.insert(0,22)
print(list1)
count1 = list1.count(2)
print(count1)
print(list1.index(4))
list1.remove(0)
print(list1)
list1.pop()
print(list1)
list1.extend(list2)
print(list1)
list1.reverse()
print(list1)
list1.sort()
print(list1)
for i in  list1:
    if i >= 3:
        print(i)
print([x+1 for x in list1])
print([x+1 for x in list1 if x>3])
```

### 3.dict的基本方法

```python
'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'
```

```python
tuple1 = (1,23,4,["shenqiang","28"],{"name":"shenqiang","age":"28"})
tuple1[3][1] = "29"
print(tuple1)
tuple1[4]["name"] = "沈强"
print(tuple1)
print(dir(tuple1))

dict1 = {'name':'shenqiang','age':'28'}
dict2 = {'adress':'nanjing'}
dict1.update(dict2)
print(dict1)
dict3 = dict1
print(dict3)
print(sorted(dict3.items(),key=lambda item:item[0]))
print(dir(dict1))
# dict1.clear()
# print(dict1)
dict1['name'] = '沈强'
print(dict1)
print(dict1.get('age'))

for key in dict1.keys():
    print(key)

for key,value in  dict1.items():
    print(key,value)
```

### 4.python的书写规范

```python
1.python的单引号和双引号注意区分
2.python的注释方法‘’‘’‘’和#的区别
3.python的str/dict/list的特点
4.注意python对缩进的严格要求
```

### 5.编码和解码

![image-20190730113608505](/Users/apple/Library/Application Support/typora-user-images/image-20190730113608505.png)

注意⚠️:python3默认的编码方式是unicode编码，如果注视里面有说明则是utf-8的编码，在 Python 3 中，字符串和 Unicode 是一家人，而且还是标准，字节流转换为字符串需要解码，字符串转化为字节流需要编码



### 6.数据类型转换

```python
# 字符串和列表之间的类型转换
str = '9,6'
list1 = str.split(',')
print(list1)
str1 = ','.join(list1)
print(str1)
print(type(str1))
```

```python
#字典转化成列表
dict1 = {'name':'shenqiang','age':18}
dict1_list = list(dict1.keys())
dict1_list1 = list(dict1.values())
print(dict1_list)
print(dict1_list1)

# 列表转化成字典
list_dict1 = dict(enumerate(dict1_list))
list1_dict1 = dict(enumerate(dict1_list1))
print(list_dict1)
print(list1_dict1)
```



## 二.python中的函数

### 1.函数的特点

```python
函数：函数是一段可以重复调用的代码，通过输入参数返回结果
名字绑定的机制，把实际参数和形式参数的名称绑定在一起
1.函数调用的时候实际参数的顺序和形式参数的顺序一一对应
2.当函数被调用的时候，指定了形式参数的实际参数，这个时候并不是一一对应的，而是根据指定的值来确定的
```

### 2.函数的参数类型（函数返回值，处理token和session）

```python
1.形式参数
2.实际参数
3.默认参数
4.动态参数（如何分离动态参数）：使用万能函数
def TryTest（*args，**kwargs）
```

```python
'''
需求：
1.对请求的参数进行ascill码排序
2.排序后，对请求的参数进行MD5加密
'''
# 排序
dict1 = {"name":"shenqiang","age":28,"datas":{"name":"shenqiang","age":28}}

def Data(**kwargs):
    return dict(sorted(kwargs.items(),key=lambda item:item[0]))

print(Data(**dict1))
```

### 3.变量类型

```python
1.全局变量
2.局部变量
3.global
```

### 4.匿名函数lambda和三目运算等（高级用法）

```python
'''
匿名函数：
lambda
'''
def Add(a,b):
    print(a+b)
Add(2,3)

per = lambda a,b:a+b
print(per(2,3))
```

```python
'''
三目运算
'''
a = 20
print("True") if a >10 else print("False")
```

```python
'''
匿名函数+三目运算
'''
login = lambda username,password:print('登录成功') if username == 'shenqiang' and password =='123' else print('登录失败')

login('shenqiang','123')
```

```python
'''
匿名函数，字典的排序
'''
data = lambda **kwargs:dict(sorted(kwargs.items(),key=lambda item:item[0]))
print(data(name='shenqiang',age = 28))
```

```python
'''函数的内部函数map(),对列表内的同样元素做同样的事情'''
list1 = [1,23,4,5,6]

print(list(map(lambda x:x+100,list1)))
```

```python
'''函数的内部函数filter(),对列表内的元素进行过滤'''
list2 = [1,2,3,4,5,6]
print(list(filter(lambda a:a>1,list2)))
```

### 5.装饰器（高级用法）

```python
'''
封闭：对已经实现功能的代码尽量不去修改
开放：对现有功能的代码进行拓展
需求：在调用f or f1 先打印getInfo，再打印f
'''
def getInfo(func):
    def info():
        print("无涯自动化测试")
        func()
    return info

@getInfo
def f():
    print("网易云平台")

@getInfo
def f1():
    print("51CTO平台")

f()

'''
步骤：
1.当我们执行getInfo时候,把被装饰的f当作参数传递
2.getInfo函数的返回值会重新赋值
3.一旦结合了装饰器，调用f函数的时候，实际调用了info内部分函数，原来的f1被覆盖
4。被装饰的f重新赋值给装饰器的info
'''
def login(func):
    def inner(Token):
        if Token == "01293":
            return func(Token)
        else:
            print("登录失败")
    return inner

@login
def profile(Token):
    print("登录成功")

profile("01293")
```

### 6.函数实战(登录注册)

```python
'''
需求：要求注册账户，注册后的账户登录系统后，显示登录的昵称
'''
def inout():
    username = input("请输入用户名：")
    password = input("请输入密码：")
    return username,password


def register():
    '''注册用户'''
    username,password = inout()
    temp = username + '|' + password
    with open("user.md", 'w') as  f:
        f.write(temp)


def login():
    '''登录用户'''
    username, password = inout()
    with open('user.md', 'r') as  f:
        temp = f.read()
    info = temp.split("|")
    if username == info[0] and password == info[1]:
        return True
    else:
        return False


def getNick(func):
    '''如果登录成功，获取用户昵称'''
    with open('user.md', 'r') as  f:
        temp = f.read()
    info = temp.split("|")
    if func:
        print('{0}恭喜您登录成功！'.format(info[0]))
    else:
        print("登录失败，请重新登录")


if __name__ == '__main__':
    while True:
        count = eval(input("1.注册，2.登录,3.退出系统"))
        if count == 1:
            register()
        elif count == 2:
            getNick(login())
        elif count == 3:
            import sys
            sys.exit(1)
        else:
            print("输入有误，请重新输入！")
            continue
```

## 三.python中包和模块

### 1.python三方库的安装和卸载

```python
python安装selenium的命令：pip install selenium==2.56.4
python卸载selenium的指令：pip unstall selenium==2.56.4
如果失败请参考百度，选择适应本地安装方式（可能存在本地有py2和py3两种情况，请把pip.exe创建快捷方式，重命名来区分）
```

### 2.python导包

```
导入包的语句：import 包名
导入包中的某个模块时 from 包名 import 模块1,模块2，模块3（如果所有请用通配符*）
注意⚠️：每一个py文件都是一个模块
```



# 第二章HTTP/HTTPS协议详解

## 一.HTTP的完成请求流程



![image-20190402144415761](/Users/apple/Library/Application Support/typora-user-images/image-20190402144415761.png)

```python
区分：URI（统一资源标识符）和URL（统一资源定位符）
熟记：200(请求成功)，302（重定向），400（请求错误），401(未授权)，403（禁止访问），404（未找到资源），500（内部服务错误），502(错误网关、无效网关)，504（网关超时）
注意⚠️：区分协议状态码和接口的响应状态码的区别

```

### 1.Cookie流程图

Cookie明文传输，存储在客户端；

session是密文传输且有时效性，存储在服务端；

token是移动端每次登录成功后，服务端随机生成的32位的字符串，且这个字符串是作为参数在body里面传递的。

![image-20190402145132195](/Users/apple/Library/Application Support/typora-user-images/image-20190402145132195.png)

### 2.Session流程图

![image-20190402145200376](/Users/apple/Library/Application Support/typora-user-images/image-20190402145200376.png)

### 3.Token流程图

![image-20190402145225335](/Users/apple/Library/Application Support/typora-user-images/image-20190402145225335.png)



## 二.HTTPS的完成请求流程

![image-20190402150000995](/Users/apple/Library/Application Support/typora-user-images/image-20190402150000995.png)



```python
注意⚠️：抓包工具charles的破解，配置（获取安全证书，抓取https协议的请求，配置抓取移动端的请求）
```

### 4.其他（Apache、Nginx和websocket协议）

Apache和Nginx工作原理，参考我的博客：https://www.cnblogs.com/shen-qiang/p/11934668.html

websocket协议工作原理，参考我的博客：https://www.cnblogs.com/shen-qiang/p/11934567.html



# 第三章Postman测试工具实战

## 一.接口测试是测什么

### 1.接口测试参数

```python
业务状态码
msg
data
```

### 2.断言数据类型

```python
1.协议状态码
2.业务状态码
3.数据断言
```



## 二.Postman实现自动化测试

### 1.自动化测试核心

```python
公共数据分离，减少代码的冗余，减少依赖关系，尽可能做到高内聚，低耦合.
```

### 2.Postman中的测试用例

```python
Postman中每一个Collections-->集合-->多个TestSuite，每一个TestSuite覆盖了一个场景下的多个接口测试case，所以每一个Collection集群了一个场景化的测试case
```

### 3.Postman中断言js的套用写法

```javascript
/*注意这个是在Tests下进行断言*/
/*序列化的处理*/

var jsonData=JSON.parse(responseBody)

/*验证协议状态码*/

pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

/*验证业务状态码*/

tests['验证业务状态码']=jsonData.code === 0

/*验证data里面的id是否等于1*/

tests['验证data里面的id值是否为1']=jsonData.data.id === 1

/*获取动态参数token
  postman中调用变量的方式{{token}}
*/
if(jsonData.data.token)
{
  tests['获取token成功']=true
  postman.setEnviromentVariable('token',jsonData.data.token);
}
else
  {
    tests['获取token失败']=false
  }

/*获取动态参数*/

 postman.setEnviromentVariable('ecouponID',jsonData.data.self_coupon[0].id;
```



### 4.接口测试的四个维度

```python
1.字段边界值的验证(一般中小厂，无严格要求，所以不需要测试)
2.字段为空的验证
3.字段类型的验证
4.基于业务的形式--->业务流程场景化是OK的  前后端的请求是OK的  
```

### 5.如何生成HTML报告

步骤一：在Collections下面选中需要生成HTML的Collection，点击Export

![image-20190402200038035](/Users/apple/Library/Application Support/typora-user-images/image-20190402200038035.png)步骤二：选中Export

![image-20190402200147762](/Users/apple/Library/Application Support/typora-user-images/image-20190402200147762.png)步骤三：文件重命名存入对应文档里

![image-20190402200252988](/Users/apple/Library/Application Support/typora-user-images/image-20190402200252988.png)步骤四：执行.json脚本

其中cd到文件的根目录，new run 执行文件名进行接口测试



![image-20190402201036290](/Users/apple/Library/Application Support/typora-user-images/image-20190402201036290.png)

![image-20190402205053553](/Users/apple/Library/Application Support/typora-user-images/image-20190402205053553.png)

步骤五 找到html报告的位置

![image-20190402210514257](/Users/apple/Library/Application Support/typora-user-images/image-20190402210514257.png)



# 第四章常用库的介绍

## 一.常见的time库

```python
import time as t

'''获得时间戳'''
print(int(t.time()))

'''获得年月日'''
print(t.localtime(t.time()))

'''获得易读的年月日'''
print(t.strftime('%y-%m-%d %H:%M:%S',t.localtime()))
```

## 二.常见的os库

```python
import os

'''调用计算机系统的指令'''
print(os.system('ifconfig'))

'''创建文件夹'''
os.mkdir('/Users/apple/Desktop/log')

# '''删除文件夹'''
# os.rmdir('/Users/apple/Desktop/log')

'''文件重命名'''
os.rename('/Users/apple/Desktop/log','/Users/apple/Desktop/Newlog')

'''当前文件所在路径'''
print('当前目录在哪个路径下',os.path.dirname(__file__))

'''当前文件所在路径的上一级路径'''
print('当前文件所在路径的上一级路径',os.path.dirname(os.path.dirname(__file__)))

'''当前文件所在路径的上一级路径的上一级路径'''
print('当前文件所在路径的上一级路径的上一级路径',os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

'''当前文件的全路径'''
print(__file__)

'''拿到文件的上级目录'''
base_dir = os.path.dirname(os.path.dirname(__file__))

'''拼接login文件里面的内容'''
file1 = open(os.path.join(base_dir,'login'),'r')

'''输出读取的文件内容'''
print(file1.read())

'''关闭文件'''
file1.close()

'''当一个接口的参数个数未知'''
def f(*args,**kwargs):
    return kwargs

'''返回的是一个字典'''
print(f(age='18',address='nanjing'))

print(f(name='shenqiang',age='18',address='nanjing'))
```

## 三.sys库/hashlib中MD5加密和导包异常处理

```python
'''
python库:
1.标准库
2.第三方库
3.自定义库
sys：
1。变量
2。常用的方法
3。sys
'''
#
import sys
#
# # print(sys.argv)
# # 第一种常用方式
# if sys.argv[1] == 'sleep':
#     print("sleep")
# else:
#     print('end')

# print(dir(sys))
# print(sys.platform)
# print(sys.version)

for item in sys.path:
    print(item)

```

![image-20191106103735176](/Users/apple/Library/Application Support/typora-user-images/image-20191106103735176.png)

```python
#当导入的模块无法识别的时候，通过以下方式把模块加入环境变量
# '''拼接文件到某个目录'''
base_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)),'Fs')
# # #把fs加到环境变量
sys.path.append(base_dir)
# '''遍历环境变量'''
for item in sys.path:
    print(item)
```

```python
from urllib import parse
import hashlib

'''
MD5加密：
1。对请求的参数进行ascill码排序 ---> dict(sorted(dict1.items(),key=lambda item:item[0]))
2。对url 进行encode编码  --->datas = parse.urlencode(req)
3。做MD5加密   生成sign(密钥) --->     MDfive = hashlib.md5()
                        MDfive.update(datas.encode('utf-8')
                        return MDfive.hexdigest()
'''
def MD5(**kwargs):
    req = dict(sorted(kwargs.items(), key=lambda item: item[0]))
    datas = parse.urlencode(req)
    MDfive = hashlib.md5()
    MDfive.update(datas.encode('utf-8'))
    return MDfive.hexdigest()

print(MD5(name = 'shenqiang',age = '28'))
```



## 四.dict/list/tuple的序列化和反序列化

```python
import json

'''
数据：
  序列化dumps：把python的数据类型转化成str的类型的过程
  反序列化loads：反序列化就是把str的数据类型转化成python的数据类型结构(字典或者列表)
文件：
	序列化dump：把内容写到文件中
	反序列化load：把文件的内容读取出来
'''

'''字典的序列化和反序列化'''
dict_str = {'name':'shenqiang','age':18,'address':'shanghai'}

#序列化，字典转化成字符串
str_dict = json.dumps(dict_str)

print(str_dict,type(str_dict))

#反序列化，字符串转化成字典
dict_str = json.loads(str_dict)

print(dict_str,type(dict_str))


'''列表的序列化和反序列化'''
list_str = ['shenqiang','18','nanjing']

#列表序列化
str_list = json.dumps(list_str)

print(str_list,type(str_list))

#列表反序列化
list_str = json.loads(str_list)

print(list_str,type(list_str))


'''元祖的序列化和反序列化,会转变成列表'''
tuple_str = ('shenqiang','20','nanjing')

#元祖的序列化
str_tuple = json.dumps(tuple_str)

print(str_tuple,type(str_tuple))

#元祖的反序列化
tuple_str = json.loads(str_tuple)

print(tuple_str,type(tuple_str))
```

## 五.接口自动化序列化和反序列化实例

要点：	1.返回参数的序列化和反序列化

​		    2.文件内容的编码和解码	

```python
import json
import requests

# '''请求来伊份后台地址'''
# base_url = requests.post(url='',data={},deaders ={})
#
# '''输出网络状态码'''
# print(base_url.status_code)
#
# '''输出返回的参数'''
# print(base_url.text,type(base_url.text))
#
# '''如果输出的text是str格式的文件,需要序列化和反序列化'''
# r = json.loads(base_url.text)
# print(r,type(r))

'''向天气预报发起请求'''
r = requests.get(url='http://www.weather.com.cn/data/sk/101190408.html')

# '''把编码成utf-8'''
# 读取requests方法输出的数据：print(r.content.decode('utf-8'))

'''对文件进行序列化-->把服务的响应写入某个文件中'''
json.dump(r.content.decode('utf-8'),open('weather.json','w',encoding='utf-8'))

'''
对文件进行反序列化，获取读取文件的内容
1.文件反序列化后是unicode类型
2.进行编码，把unicode类型转换成str类型
3.然后使用反序列化，把str类型转换成字典
'''

load = json.load(open('login.json','r'))

print(load,type(load))

'''对str类型文件内容进行反序列化，读取city的value'''
city = json.loads(load)['weatherinfo']['city']

print('查询的城市是：',city)
```

## 六.实例：将序列化和反序列化应用于登陆注册系统

```python
# #!/usr/bin/env python
# # -*- coding: utf-8 -*-
# # @Time : 2019-11-04 22:10
# # @Author : shenqiang
# # @File : TryLogin.py
# # @Software: PyCharm

import  json

'''
需求：要求注册账户，注册后的账户登录系统后，显示登录的昵称
'''
def inUserName():
    '''
    :param username:用户名
    :return username:用户名
    '''
    username = input("请输入用户名：")
    return username

def inPassWord():
    '''
    :param password:密码
    :return password:密码
    '''
    password = input("请输入密码：")
    return password

def register():
    '''注册用户'''
    username,password = inUserName(),inPassWord()
    temp = username + '|' + password
    json.dump(temp,open('user.md','w'))

def login():
    '''登录用户'''
    username, password = inUserName(),inPassWord()
    temp = json.load(open('user.md','r'))
    info = temp.split("|")
    if username == info[0] and password == info[1]:
        return True
    else:
        return False

def getNick(func):
    '''如果登录成功，获取用户昵称'''
    temp = json.load(open('user.md', 'r'))
    info = temp.split("|")
    if func:
        print('{0}恭喜您登录成功！'.format(info[0]))
    else:
        print("登录失败，请重新登录")

if __name__ == '__main__':
    while True:
        try:
            count = eval(input("1.注册，2.登录, 3.退出系统"))
            if isinstance(count,float):
                count = int(count)
        except Exception as  e:
            print(e.args)
        else:
            if count == 1:
                register()
            elif count == 2:
                getNick(login())
            elif count == 3:
                import sys
                sys.exit(1)
            else:
                print("输入有误，请重新输入！")
                continue

```

# 第五章 Python文件和异常的处理

## 一.异常知识

### 1.异常处理的格式

```python
try:
    div1(a,b)
except Exception as E:
    print(E.args)
```

### 2.异常处理的Body

```python

'''
执行顺序：
try(如果执行成功)，先执行try，再执行else代码，最后执行finally
try(如果执行失败)，先执行except代码，最后执行finally
'''
def TestTry(self):
    try:
        if self == '1':
            print('try')
        else:
            print('false')
    except:
        print('except')
    else:
        print('else')
    finally:
        print('finally')

TestTry("1")
```



### 3.异常的类型

| 异常名称                  | 描述                                               |
| :------------------------ | :------------------------------------------------- |
|                           |                                                    |
| BaseException             | 所有异常的基类                                     |
| SystemExit                | 解释器请求退出                                     |
| KeyboardInterrupt         | 用户中断执行(通常是输入^C)                         |
| Exception                 | 常规错误的基类                                     |
| StopIteration             | 迭代器没有更多的值                                 |
| GeneratorExit             | 生成器(generator)发生异常来通知退出                |
| StandardError             | 所有的内建标准异常的基类                           |
| ArithmeticError           | 所有数值计算错误的基类                             |
| FloatingPointError        | 浮点计算错误                                       |
| OverflowError             | 数值运算超出最大限制                               |
| ZeroDivisionError         | 除(或取模)零 (所有数据类型)                        |
| AssertionError            | 断言语句失败                                       |
| AttributeError            | 对象没有这个属性                                   |
| EOFError                  | 没有内建输入,到达EOF 标记                          |
| EnvironmentError          | 操作系统错误的基类                                 |
| IOError                   | 输入/输出操作失败                                  |
| OSError                   | 操作系统错误                                       |
| WindowsError              | 系统调用失败                                       |
| ImportError               | 导入模块/对象失败                                  |
| LookupError               | 无效数据查询的基类                                 |
| IndexError                | 序列中没有此索引(index)                            |
| KeyError                  | 映射中没有这个键                                   |
| MemoryError               | 内存溢出错误(对于Python 解释器不是致命的)          |
| NameError                 | 未声明/初始化对象 (没有属性)                       |
| UnboundLocalError         | 访问未初始化的本地变量                             |
| ReferenceError            | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |
| RuntimeError              | 一般的运行时错误                                   |
| NotImplementedError       | 尚未实现的方法                                     |
| SyntaxError               | Python 语法错误                                    |
| IndentationError          | 缩进错误                                           |
| TabError                  | Tab 和空格混用                                     |
| SystemError               | 一般的解释器系统错误                               |
| TypeError                 | 对类型无效的操作                                   |
| ValueError                | 传入无效的参数                                     |
| UnicodeError              | Unicode 相关的错误                                 |
| UnicodeDecodeError        | Unicode 解码时的错误                               |
| UnicodeEncodeError        | Unicode 编码时错误                                 |
| UnicodeTranslateError     | Unicode 转换时错误                                 |
| Warning                   | 警告的基类                                         |
| DeprecationWarning        | 关于被弃用的特征的警告                             |
| FutureWarning             | 关于构造将来语义会有改变的警告                     |
| OverflowWarning           | 旧的关于自动提升为长整型(long)的警告               |
| PendingDeprecationWarning | 关于特性将会被废弃的警告                           |
| RuntimeWarning            | 可疑的运行时行为(runtime behavior)的警告           |
| SyntaxWarning             | 可疑的语法的警告                                   |
| UserWarning               | 用户代码生成的警告                                 |

## 二.接口测试简介

### 1.接口测试的维度

```python
'''
接口测试的纬度：
1.边界值测试（一般大型公司测试）
2.参数为空
3.参数类型
4.业务测试
自动化的范畴：
安全      性能
业务纬度测试：
1.功能接口自动化测试
    关注：
    1.用户操作流程
2.接口自动化测试
    关注：
    1.JS代码不能出问题
    2.前后端交互没有问题
    3.场景化/流程/逻辑不能出问题
    4.高频的用户场景
'''
```

## 三.文件的操作

### 1.文件操作的通用方式

问题：可能会忘记 close file，导致内存泄漏

```python
import json

'''
open的参数：
1.要操作的文件名称
2.以什么样的方式操作文件：
r：只读模式
w：只写模式【不可读，不存在就创建，存在就清空文件内容】
x：只写模式【不可读，不存在就创建，存在就报错】
a：增加模式【可读，不存在就创建，存在只增加里面的内容】
'+'表示可以同时读写某个文件，比如：
r+：读写
w+：写读
X+：写读
a+：写读
'''
file1 = open('file.json','w+')
temp = {
'name':'shenqiang',
'age':18,
'address':'nanjing'
}
# # for line in temp:
# #     file1.write(line)
# file1.writelines(temp)
# file1.close()

'''文件的序列化'''
json.dump(temp,open('file.json','w+'))
```

### 2.文件操作的优化方案

使用with，系统会自动帮助关闭文件，防止内存溢出

```python
'''文件的上下文的处理'''
with open('Test1','w+') as T:
    T.write('这种操作方式可以系统帮助关闭，可以避免很多问题，会自动close，避免内存泄漏')
```

# 第六章python的面向对象详解

## 一.OOP是什么？

### 1.OOP的定义

python3和python2的映射区别

```python
f2 = f()
f1 = f()
print(id(f1))
print(id(f2))
    python3的一个对象，映射关系是同一个id。python2的对象，每次调用都会新生成一个地址
```

```python
'''
类：是由一些属性和方法组成的
'''
def f():
    pass

''' 
对象的创建--->类的事例化过程
三个特性：
1.对象的句柄--->区分不同的对象
2.属性
    共有属性
				类属性（共同的属性分离出来）：属于类也属于对象
        实例属性：只属于对象
        局部变量
    私有属性
3.方法  
'''
class Person(object):
    '''类属性'''
    gongtong = ‘China’
    def __init__(self,name,age):
        '''实例属性'''
        self.name = name
        self.age = age

    def getName(self):
        return self.name

    def getAge(self):
        return self.age

    def setName(self,name):
        self.name = name

    def setAge(self,age):
        self.age = age

 		def info(self):
        return 'name:{0},age:{1}'.format(self.name,self.age)

# 实例化Person
per = Person('shenqiang','28')
per2 = Person('lll','20')
print(per.getName(),per.getAge())

per2.setAge('10')
per2.setName('shen')
print(per2.getAge(),per2.getName())

pel = Person('沈强',18)
print(pel.getAge(),pel.getName())
print(pel.info())
```

### 2.构造函数

```python
'''
满足所有人类的个性，调用万能参数
构造函数：即使没写构造函数，类都是有构造函数的
一个类可以有多个构造函数，建议一个类只有一个构造函数
构造函数用来：
1.初始化属性
'''
class Person(object):
    def __init__(self,**kwargs):
        self.kwargs = kwargs

    def getInfo(self):
        print(list(self.kwargs.values()))

per = Person(name='shenqiang',age = '28')
per.getInfo()
```

### 3.析构函数

任何情况下都会最后执行析构函数

```python
'''析构函数的执行顺序：
对象实例化->构造函数->对象调用方法->代码跳转到具体的方法->执行方法的代码块->最后执行析构函数
'''
class person(object):
    def __init__(self):
        print('我是构造函数')

    def __del__(self):
        print('我是析构函数')

    def info(self):
        print('我是方法')
#实例化方法
per = person()
#调用方法
per.info()
```

## 二.OOP方法讲解

```python
'''
属于类：
    类属性
    静态方法
    类方法
属于对象：
    实例属性
    普通方法
    特性方法
'''
```

### 1.普通方法

```python
'''
普通方法
    动态方法（万能参数）
特性方法

'''

class Person():

    def cnn(self):
        pass

    def f1(self,*args,**kwargs):
        self.args = args
        self.kwargs = kwargs

    def info(self):
        print('这是个普通的方法')

per = Person()
per.info()
```

### 2.特性方法

```python
'''
特性方法：
不能有形式参数
被调用的时候不要加（）
'''
class person(object):
    '''特性方法调度@property'''
    @property
    def getUserId(self):
        pass

per = person
per.getUserId
```

### 3.静态方法

```python
'''
静态方法：直接使用类名进行调用，它属于类
对象可以直接调用静态方法，一般不建议这么做
'''
class MYSQL(object):
    '''静态方法，直接提供给全局调用'''
    @staticmethod
    def cnn():
        return '静态方法'

print(MYSQL.cnn())
```

### 4.类方法

```python
'''
类方法：直接使用类来调用
所有的用例在执行的时候只执行一次
'''
class Person(object):

    @classmethod
    def cnn(cls):
        pass
```

### 5.方法说明

​	方法用来描述对象所具有的行为，例如，列表对象的追加元素、插入元素、删除原宿、排序，字符串对象的分隔、连接、排版、替换、烤箱的温度设置、烘烤，等等

　　在类中定义的方法可以粗略分为四大类：公有方法、私有方法、静态方法和类方法。公有方法、私有方法一般是指属于对象的实例方法，其中私有方法的的名字以两个下划线（__）开始。每个对象都有自己的公有方法和私有方法，在这两类方法中都可以访问属于类和对象的成员；公有方法通过对象名直接调用，私有方法不能通过对象名直接调用，只能在实例中通过self调用，或在外部通过Python支持的特殊方式来调用.

　　类的所有实例方法都必须至少有一个名为self的参数，并且必须是方法的第一个形参（如果有多个形参的话），self参数代表对象自身。在类的实例方法中访问实例属性时需要以self为前缀，但在外部通过对象名调用对象方法时，并不需要传递这个参数，如果在外部通过类名调用属于对象的公有方法，需要显式为该方法的self参数传递一个对象名，用来明确指定访问哪个对象的数据成员。

　　静态方法和类方法都可以通过类名和对象名调用，但不能直接访问属于对象的成员，只能访问属于类的成员。一般将cls作为类方法的第一个参数，表示该类自身，在调用类方法时不需要为该函数传递值。

## 三.继承

### 1.类属性的继承

```python
'''
继承：重用已有的数据和方法，减少代码的重复编写
子类继承父类所有的实例变量和方法
'''
# 类属性的继承
class Person(object):

    address = '地球'

class UsaPerson(Person):
    pass

per = UsaPerson()
print(per.address)
```

### 2.实例属性的继承（super方法）

```python
'''实例属性的继承和继承的两种方法'''
class Fruit(object):

    def __init__(self,name):
        self.name =name

'''由于业务需求，子类继承父类的实例属性'''
class Apple(Fruit):

    def __init__(self,name,brand,color):
        '''子类继承父类的两种方式'''
        Fruit.__init__(self,name)
        # super(Apple,self).__init__(name)
        self.brand = brand
        self.color = color

    def info(self):
        return('我是水果{0},我的的品牌是{1}，我是{2}色的'.format(self.name,self.brand,self.color))

apple = Apple('banana','baiguoyuan','yellow')
print(apple.info())


'''由业务需求，子类不继承父类的实例属性'''

class apple(Fruit):

    def __init__(self,brand,color):
        self.brand = brand
        self.color = color

    def info(self):
        return('我的的品牌是{0}，我是{1}色的'.format(self.brand,self.color))

apple = apple('baiguoyuan','yellow')
print(apple.info())
```

### 3.方法的继承

#### 单继承

```python
'''
方法的继承：
1.子类为什么重写父类的方法：子类要有自己的特性
当子类重写父类的方法后，对子类进行实例化，子类调用的方法（父类/子类）都存在，执行的方法是子类的方法（从下到下）

单个类继承的原则：
1。子类继承了父类，但是子类没有重写父类的方法，使用的是父类的方法（从上而下）
2。子类继承了父类，但是子类重写了父类的方法，使用的是子类的方法，子类优先使用自己的方法（从上而下）
'''
class Fruit(object):

    def eat(self):
        print ('水果是可以吃的')


class Apple(Fruit):
    def __init__(self,color):
        self.color = color
    '''重写了eat方法'''
    def eat(self):
        print('水果的颜色是：{0}'.format(self.color))

class Banana(Apple):
    def eat(self):
        print('myname is banana')

apple = Apple('yellow')
apple.eat()

# 需要一个对象，可以给个空对象
Banana('').eat()
```

#### 多继承

```python
'''
多个类继承：
1.从左到右
2.同级继承，跨级会报错
3.优先调用自己的函数
⚠️延伸:新式类（object）C3算法（广度优先）和经典类（深度优先）
'''
class Person(object):
    def eat(self):
        print('Person need eat')

class Mother(Person):
    def eat(self):
        print('her is like eat fruit')

class Father(Person):
    def eat(self):
        print('hi is like eat Vegetables')

class Son(Father,Mother):
    pass

son = Son()
son.eat()
```

### 4.登陆实战案例

```python
import json
import sys

class Login(object):
    def __init__(self,username,password):
        self.username = username
        self.password = password

    def getUsername(self):
        return self.username

    def setUsername(self,username):
        self.username = username

    def getPassword(self):
        return self.password

    def setPassword(self,password):
        self.password = password

    def register(self):
        '''
        注册
        '''
        temp = self.username+'|'+self.password
        '''改写，序列化和反序列化'''
        json.dump(temp,open('login', 'w'))
        print('恭喜你注册成功！')

    def login(self):
        f = str(json.load(open('login', 'r')))
        list1 = f.split('|')
        if list1[0] == self.username and list1[1] == self.password:
            return True
        else:
            return False

    def userInfo(self):
        '''改写，序列化和反序列化'''
        f = str(json.load(open('login', 'r')))
        list1 = f.split('|')
        '''验证用户等登陆是否成功'''
        r = self.login()
        if r:
            print('登陆成功！用户昵称为：{0}'.format(list1[0]))
        else:
            print('登陆失败！请检查您的账号和密码！')

    def Exit(self):
        sys.exit('')
        print('您已退出该系统!')

r = Login('shenqiang','shen111')
def main():
    while True:
        try:
            t = int(input('1。注册；2。登陆;3。退出登陆 \n'))
        except Exception as e:
            print(e.args)
        else:
            if t == 1:
                r.register()
            elif t == 2:
                r.userInfo()
            elif t == 3:
                r.Exit()
            else:
                print('输入错误，请重新输入！')
        finally:
            pass

if __name__ == '__main__':
    main()
```

### 5.工厂模式（包含_ _call_ _ _,_ _ _str_ _ _,_ _ _doc_ _）



```python
'''__call__:当函数调用__call__，函数内部生成的是静态方法'''
class New(object):
    def __call__(self, *args, **kwargs):
        print('我是一个静态方法')

new = New().__call__()
```

注意：_ _str_ _的方法使用

```python
'''
__str__：对象代表的含义，返回一个字符串，通过它可以把字符串和对象关联起来，方便某些程序的实现，该字符串表示了某个类，实现__str__后，可以直接使用print输出对象，也可以用str触发__str__的执行
__doc__：打印出类的注释
1.对象的意思
2.返回一个字符串，把字符串和对象关联起来-->该字符串表示这个对象
'''

class Try(object):
    '''这事一个类'''
    def __str__(self):
        print(self.__doc__)

try1 = Try().__str__()

'''工厂模式'''

class Factory(object):
    def CreateFruit(self,Fruit):
        if Fruit == 'apple':
            return Apple()
        elif Fruit == 'banana':
            return Banana()

class Fruit():
    def __str__(self):
        return 'Fruit'

class Apple():
    def __str__(self):
        return 'apple'

class Banana():
    def __str__(self):
        return 'banana'

if __name__ == '__main__':
    factory = Factory()
    print(factory.CreateFruit('apple'))
    print(factory.CreateFruit('banana'))
```

# 第七章 Jmeter实现接口自动化测试

## 一.Jmeter的插件安装和HTTP请求格式

### 1.Jmeter插件安装

插件名：jmeter-plugins-manager

用途：管理和安装其他插件

所在路径：/Applications/apache-jmeter-5.1.1/lib/ext/

安装插件名：JSON/YAML Plugins（json支持插件）

​			PerfMon（性能测试插件）

​			WebSocket*（WebSocket相关接口）



### 2.HTTP请求格式

层级关系：

测试计划

​	查看结果树

线程组

​	简单控制器

​		HTTP信息头管理

​		HTTP请求

## 二.Jmeter正则表达式

### 1.正则表达式测试地址

http://tool.oschina.net/regex/

### 2.动态参数的获取方法

Tocken的正则表达式模版：

![image-20190413165314648](/Users/apple/Library/Application Support/typora-user-images/image-20190413165314648.png)

Token的json格式调用

![image-20190413174539515](/Users/apple/Library/Application Support/typora-user-images/image-20190413174539515.png)

## 三.断言的内容和方式

接口测试需要验证：

1.协议状态码

2.响应内容

3.业务状态码

4.数据断言

断言方式：

使用json插件断言，可以指定字段的位置，跟随业务和前段进行测试，响应断言没有目标位置，可能代码结构存在异常



![image-20190413195517684](/Users/apple/Library/Application Support/typora-user-images/image-20190413195517684.png)

## 三.ant和build.xml文件配置

### 1.ant安装和build.xml基础配置

```python
测试报告步骤：
1.搭建ant环境(path的环境变量)
cmd的命令提示符输入ant or ant - v
2、jmerer的目录C:\apache - jmeter - 4.0\extras下找到ant - jmeter - 1.1
.1.jar, 把它copy到ant的apache - ant - 1.10
.0\lib下
3、打开jmeter的bin目录下的jmeter.properties文件，做如下修改:
把jmeter.save.saveservice.output_format = csv
修改为jmeter.save.saveservice.output_format = xml

4、编写build.xml文件
A.执行测试脚本
B.生成测试报告(html)
C.自动发送邮件
5、执行, 执行命令：
cd C:\apache - jmeter - 4.0\TestSuite
c:
ant
```

### 2.自动发送邮件配置

```python
自动发送邮件问题总结：
1、自动发送邮件，需要三个jar，分别是：activation.jar,
commons - email - 1.2.jar, mail.jar, 这三个文件放在ant的lib目录下
2、Exception reading response timeout stack jire -->JRE
3、auhtoration, 401, 403

Jmerer加到环境变量的步骤：
1.创建JMETER_HOME, 加C:\apache - jmeter - 4.0
2.CLASSPATH里面加:
CLASSPATH = % JMETER_HOME %\lib\ext\ApacheJMeter_core.jar; % JMETER_HOME %\lib\jorphan.jar;
3.path环境变量里面加:
% JMETER_HOME % / bin;
4.jmeter测试
```

### 3.jmeter性能报告的生成

```python
Jmeter生成性能测试报告
1.修改配置文件jmeter.properties(或者不需要修改，直接是默认的)
  jmeter.save.saveservice.output_format = csv
2.到脚本目录下
cd C:\apache - jmeter - 4.0\TestSuite\script
3.直接执行

jmeter -n -t MiddleStageTest.jmx -l MiddleStage.jtl -e -o /Applications/apache-jmeter-5.1.1/TestSuite/report/jtl_report/

3.注意⚠️：每次执行清空生成的文件（包含隐藏文件），删除script下的logo和jtl文件
模板的定制：
C:\apache - jmeter - 4.0\bin\report - template
```

### 4.premon插件的应用

```python
permon(监控服务器CPU，I/O，内存等)插件的应用：
1.下载permon的插件
2.下载ServerAgent - 2.2.1, 并且解压
3.监听器中添加permon
4.启动serverAgent的插件, 监听端口的4444
5.点击默认点击localhost(也就是本机)

查询所有端口的占用情况：
sudo lsof -i -P | grep -i "listen"

查询某端口是否被占用：
sudo lsof -i :3306
  
终止某个端口的程序：
sudo kill 716

linux系统的状态统计
top指令观察系统里面的资源占用信息
其中：PID：进程ID VIRT虚拟内存的大小 RES物理内存大小 SHR共享内存大小  %MEM内存占用比例 %CPU CPU占用比例 

top | grep sys*
```

## 四.解析基于Jmeter的性能测试报告

Jmeter性能测试报告：

**图表信息详解**

测试报告分为两部分，Dashboard和Charts，下面分开解析。

**1、Dashboard（概览仪表盘）**

**①、Test and Report informations**

![image-20191115091439121](/Users/apple/Library/Application Support/typora-user-images/image-20191115091439121.png)

**②、APDEX (应用性能指标)**

关于APDEX的相关信息，请参考这里：[应用性能指标](http://oneapm.udesk.cn/hc/articles/515)；英文原文，参考这里：[Apdex-Wikipedia](https://en.wikipedia.org/wiki/Apdex)

![image-20191115091507151](/Users/apple/Library/Application Support/typora-user-images/image-20191115091507151.png)

**③、Requests Summary**

![image-20191115091535814](/Users/apple/Library/Application Support/typora-user-images/image-20191115091535814.png)

**2、Charts（详细信息图表）**

**PS：**由于详细信息图表有点多，这里我挑几个性能测试过程中比较关键的图表解析！

**Over Time**

**①、Response Times Over Time（脚本运行期间的响应时间变化趋势图）**

说明：可以根据响应时间和变化和TPS以及模拟的并发数变化，判断性能拐点的范围。

![image-20191115091352582](/Users/apple/Library/Application Support/typora-user-images/image-20191115091352582.png)

**②、 Response Time Percentiles Over Time (successful responses)**

说明：脚本运行期间成功的请求响应时间百分比分布图，可以理解为聚合报告里面不同%的数据，图形化展示的结果。

![image-20191115091648608](/Users/apple/Library/Application Support/typora-user-images/image-20191115091648608.png)

**③、Bytes Throughput Over Time（脚本运行期间的吞吐量变化趋势图）**

说明：在容量规划、可用性测试和大文件上传下载场景中，吞吐量是很重要的一个监控和分析指标。

![image-20191115091716145](/Users/apple/Library/Application Support/typora-user-images/image-20191115091716145.png)

**④、 Latencies Over Time（脚本运行期间的响应延时变化趋势图）**

说明：在高并发场景或者强业务强数据一致性场景，延时是个很严重的影响因素。

![image-20191115091743687](/Users/apple/Library/Application Support/typora-user-images/image-20191115091743687.png)

**Throughput**

**①、Transactions Per Second（每秒事务数）**

说明：每秒事务数，即TPS，是性能测试中很重要的一个指标，它是用来衡量系统处理能力的一个重要指标。

![image-20191115091815594](/Users/apple/Library/Application Support/typora-user-images/image-20191115091815594.png)

**Response Times**

**①、 Response Time Percentiles（响应时间百分比分布曲线图）**

说明：即响应时间在某个范围内的请求在所有请求数中所占的比率，相比于平均响应时间，这个值更适合用来衡量系统的稳定性。

![image-20191115091844739](/Users/apple/Library/Application Support/typora-user-images/image-20191115091844739.png)

**②、Time Vs Threads（平均响应时间和线程数的对应变化曲线）**

说明：可以通过这个对应的变化曲线来作为确定性能拐点的一个参考值。

![image-20191115091911313](/Users/apple/Library/Application Support/typora-user-images/image-20191115091911313.png)

**3、添加所需监听器，导入日志文件即可查看**
在性能测试过程中，我们往往需要将测试结果保存在一个文件当中，也可以为日后的性能测试报告提供更多的素材

在Jmeter中，结果都存放在 **.jtl**文件中，格式有很多种，可以根据需要进行更爱，选择某个监听器，在**configure页面**进行相应配置，让我们来查看下保存后的文件有哪些内容：

![img](https://upload-images.jianshu.io/upload_images/5999951-d59ad56615a379cf.png?imageMogr2/auto-orient/strip|imageView2/2)

- timeStamp：请求发出的绝对时间
- elapsed：响应时间
- label：HTTP请求名称
- responseCode：请求返回码
- responseMessage：请求返回消息
- threadName：请求所属的线程名称
- dataType：数据类型
- success：是否成功
- failureMessage：失败信息
- bytes：字节
- sentBytes：发送字节数
- grpThreads：
- allThreads：
- Latency：延迟
- IdleTime：思考时间
- Connect：连接

接下来添加一个聚合报告，然后导入日志文件，查看结果，还可以添加其他的监听器，操作方法一样

![img](https://upload-images.jianshu.io/upload_images/5999951-d36ef092f83624ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

PS：如果测试计划中增加了监听器（生成概要结果），在执行命令时就可以看到每个线程的执行情况

![img](https://upload-images.jianshu.io/upload_images/5999951-ce26bf722b4a823f.png?imageMogr2/auto-orient/strip|imageView2/2)

**PS：设置好线程数、循环次数、集合点、事务、断言、关联等等后即可执行压力测试**

### 最后，大并发下还是需要进行分布式性能测试

原理和LR的agent差不多，因为jmeter由Java开发，耗内存、cpu，所以需要采用分布式

步骤：
1、关闭防火墙
2、在所要运行jmeter并作为负载生成器的机器上安装jmeter（确保在所有系统中使用了相同版本号的Jmeter和jdk）
**PS：目标服务器需要在相同网段，确保Jmeter可以访问目标服务器**
3、确定其中一台机器作为主controller，其他的机器作为agent，然后运行所有agent机器上的jmeter-server文件
4、在controller机器的jmeter中bin目录下，找到jmeter.properties文件，添加节点IP，修改localhost为压力机IP

![img](https://upload-images.jianshu.io/upload_images/5999951-5064d29acf74fb67.png?imageMogr2/auto-orient/strip|imageView2/2)

5、启动conttoller机子上的jmeter应用，选择菜单【运行】---远程启动来分别启动agent，也可以直接选择【远程全部启动】来将所有个agent启动

**在性能测试过程中，我们通常需要将测试结果保存在一个文件当中，既可以保存测试结果，也可以为日后的性能测试报告提供更多的素材**

**Jmeter中，结果都存放在.jtl文件，一般以csv文件格式记录，只需要选择某个监听器，点击页面的configure按钮，建议勾选如下项：Save Field Name，Save Assertion Failure Message**

## 五.性能测试分析方法

#### 1.用户登录并发测试（性能测试通过）

![image-20191108175726213](/Users/apple/Library/Application Support/typora-user-images/image-20191108175726213.png)

![image-20191108182631455](/Users/apple/Library/Application Support/typora-user-images/image-20191108182631455.png)

![image-20191108182659766](/Users/apple/Library/Application Support/typora-user-images/image-20191108182659766.png)

![image-20191108182724199](/Users/apple/Library/Application Support/typora-user-images/image-20191108182724199.png)

![image-20191108182748531](/Users/apple/Library/Application Support/typora-user-images/image-20191108182748531.png)

![image-20191108182815628](/Users/apple/Library/Application Support/typora-user-images/image-20191108182815628.png)

![image-20191108182900011](/Users/apple/Library/Application Support/typora-user-images/image-20191108182900011.png)

#### 2.用户登录业务量测试（性能测试通过）

![image-20191108183356616](/Users/apple/Library/Application Support/typora-user-images/image-20191108183356616.png)

![image-20191108183513453](/Users/apple/Library/Application Support/typora-user-images/image-20191108183513453.png)

![image-20191108183536218](/Users/apple/Library/Application Support/typora-user-images/image-20191108183536218.png)

![image-20191108183600960](/Users/apple/Library/Application Support/typora-user-images/image-20191108183600960.png)

![image-20191108183633929](/Users/apple/Library/Application Support/typora-user-images/image-20191108183633929.png)

**业务量思考时间和等待时间去除，需要再次测试**。

#### **3.随机购物并发测试（测试不通过）**

**响应时间**

![image-20191108193636242](/Users/apple/Library/Application Support/typora-user-images/image-20191108193636242.png)

**APDEX**

![image-20191108193716757](/Users/apple/Library/Application Support/typora-user-images/image-20191108193716757.png)

**业务成功率**

![image-20191108193811022](/Users/apple/Library/Application Support/typora-user-images/image-20191108193811022.png)

**并发数**

![image-20191108193843004](/Users/apple/Library/Application Support/typora-user-images/image-20191108193843004.png)

**资源使用情况**

![image-20191108193949449](/Users/apple/Library/Application Support/typora-user-images/image-20191108193949449.png)

图形分析：

1.从资源使用情况上看，内存正常，CPU明显异常

性能分析：

CPU上升常见原因

1.程序算法异常

2.调用外部接口API的程序

3.CPU配置不高，运算低

4.系统程序不支持多线程

内存使用偏高常见原因：

1.内存泄漏，内存用完，没有得到及时释放

2.内存对象，处理上一场（垃圾过多，内存回收效率低）

3.内存不足（需要增加内存）



![image-20191108194735587](/Users/apple/Library/Application Support/typora-user-images/image-20191108194735587.png)

![image-20191108194813605](/Users/apple/Library/Application Support/typora-user-images/image-20191108194813605.png)

![image-20191108195131660](/Users/apple/Library/Application Support/typora-user-images/image-20191108195131660.png)

#### 4.随机购物业务量测试(测试不通过)

需求：![image-20191108195535915](/Users/apple/Library/Application Support/typora-user-images/image-20191108195535915.png)

执行结果分析：

![image-20191108195609061](/Users/apple/Library/Application Support/typora-user-images/image-20191108195609061.png)

系统资源趋势图：

![image-20191108195642665](/Users/apple/Library/Application Support/typora-user-images/image-20191108195642665.png)

性能测试分析：

通过日志发现，异常原因是数据库异常，需要开发人员排查

# 第八章单元测试框架 unittest

## 一.单元测试框架的组成和职能

### 1.单元测试框架的关系

![image-20190415103133074](/Users/apple/Library/Application Support/typora-user-images/image-20190415103133074.png)

### 2.单元测试框架的组成和职能 

TestCase：单元测试中最小纬度的行为

TestFixure：执行测试前准备的工作（打开浏览器/关闭浏览器，打开/关闭数据库等）

TestSuite：TestCase的集合，用来集合所有的TestCase，可以看作一种容器

TestRunner：测试的执行，先到模块，再到类，到对应模块，再到TestCase。用来运行测试，收集测试数据，呈现给用户

TestReport：测试报告（可视化测试数据）

### 3.单元测试现有的问题

1.国内大多数企业测试驱动模型没有定义

2.哪些是主要测试，哪些做简单的测试，哪些不需要测试，哪些需要做性能测试等等

## 二.Unittest内容

### 1.测试固件和特点

​	a.setUp&tearDown:有多少个test setUp&tearDown就执行多少次

​	b.setUpClass&tesrDownClass：

​	c.程序执行的顺序

​	d.测试用例的编写方式

### 2.输出方式（verbosity）

- 0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共100个 失败20 成功80
- 1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”
- 2 (详细模式):测试结果会显示每个测试用例的所有相关的信息

### 3.Unittest实现webdriver事例

#### 小技巧：如何提高浏览器访问的效率：地址配置给host

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep
from selenium import webdriver

'''
调用类方法，只执行一次setup和teardown
self.diver.back() 每次动作后返回到操作前
test_001_baidu_news通过控制最前面的数字控制执行顺行(默认通过ASCLL编排执行顺序)
'''
'''使用浏览器打开'''

class F2(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.dirver = webdriver.Chrome()
        cls.dirver.maximize_window()
        cls.dirver.get("https://www.baidu.com/")
        cls.dirver.implicitly_wait(30)

    @classmethod
    def tearDownClass(cls):
        cls.dirver.quit()

    '''百度首页链接测试'''
    def test_001_baidu_news(self):
        '''首页链接测试：验证新闻的链接'''
        self.dirver.find_element_by_link_text("新闻").click()
        sleep(2)
        self.dirver.back()

    def test_002_baidu_map(self):
        '''首页链接测试：验证贴吧的链接'''
        self.dirver.find_element_by_link_text("贴吧").click()
        sleep(2)
        self.dirver.back()

    '''百度首页搜索测试'''
    def test_003_baidu_search(self):
        '''首页搜索：搜索webdirver'''
        self.dirver.find_element_by_id('kw').send_keys('webdirver')
        self.dirver.back()

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

### 4.测试套件（TestSuite⚠️）

能够输出对应的test 下的问题

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from selenium import webdriver

'''
调用类方法，只执行一次setup和teardown
self.diver.back() 每次动作后返回到操作前
'''
class BaiduTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')

    @classmethod
    def tearDownClass(cls): 
        cls.diver.quit()

    def test_baidu_001(self):
        '''测试点击新闻后是否会跳转'''
        self.diver.find_element_by_link_text('新闻').click()
        self.diver.back()
        sleep(5)

    def test_baidu_002(self):
        '''测试点击贴吧后是否会跳转'''
        self.diver.find_element_by_partial_link_text('贴吧').click()
        # self.diver.back()
        sleep(5)

if __name__ == '__main__':
    # unittest.main(verbosity=2)
    '''按照模块运行'''
    suite = unittest.TestSuite(unittest.makeSuite(BaiduTest))
    unittest.TextTestRunner(verbosity=2).run(suite)
    
    '''加载整个测试类'''
    suite = unittest.TestLoader().loadTestsFromTestCase(BaiduTest)
    unittest.TextTestRunner(verbosity=2).run(suite)
    
    '''加载整个模块'''
    suite = unittest.TestLoader().loadTestsFromModule('模块名.py')
    unittest.TextTestRunner(verbosity=2).run(suite)
```

### 5.TestSuite公共参数分离

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from selenium import webdriver

class Baidu_Search(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')

    @classmethod
    def tearDownClass(cls):
        cls.diver.quit()

    def test_link(self):
        self.diver.find_element_by_id('kw').send_keys('无涯')
        sleep(5)

    '''静态方法分离'''
    @staticmethod
    def suite():
        suite = unittest.TestLoader().loadTestsFromModule('U_test.py')
        return suite

if __name__ == '__main__':
    '''执行某个模块的测试'''
    unittest.TextTestRunner(verbosity=2).run(Baidu_Search.suite())
```

### 6.分离测试固件（核心掌握分离思想）

1.目录结构

![image-20190416152330575](/Users/apple/Library/Application Support/typora-user-images/image-20190416152330575.png)

2.调用方法

![image-20190416152403017](/Users/apple/Library/Application Support/typora-user-images/image-20190416152403017.png)

3.语法内容

```
Test_Head.py 被调文件
```

```python
import unittest
from selenium import webdriver

class TestHead(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')


    @classmethod
    def tearDownClass(cls):
        cls.diver.quit()
```

```
BuiltinMethod.py 调用文件
```

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

from time import sleep
from base.Test_Head import *

def add(a,b):
    return  a-b

class Baidu_Search(TestHead):

    @unittest.skip("忽略这条测试用例")
    def test_link(self):
        self.diver.find_element_by_id('kw').send_keys('无涯')
        self.diver.back()
        sleep(5)

    def test_News(self):
        self.diver.find_element_by_link_text('新闻').click()
        sleep(5)
        
    '''期待运行失败的用例'''
    @unittest.expectedFailure
    def test_004(self):
        self.assertEqual(add(2,3),1)

    '''静态方法分离'''
    @staticmethod
    def suite():
        suite = unittest.TestLoader().loadTestsFromModule('U_test.py')
        return suite

if __name__ == '__main__':
    '''执行某个模块的测试'''
    unittest.TextTestRunner(verbosity=2).run()
```

### 7.unittest断言和断言方法

![image-20190416160352711](/Users/apple/Library/Application Support/typora-user-images/image-20190416160352711.png)

调用6中分离的公共模块，断言代码

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
from base.Test_Head import *

class BaiduTitle(TestHead):

    def test_BaiduTitleTest(self):
        self.assertEqual(self.diver.title,'百度一下，你就知道')

    def test_Baidukw(self):
        so = self.diver.find_element_by_id('kw')
        self.assertTrue(so.is_enabled(),True)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

##### 注意⚠️（确保API自动化和UI自动化的价值）：

1.如何提升API自动化和UI自动化的价值（权威化TestCase）

2.如何确保测试出来的false，直观化，一定不能断言失误

3.能通过自动化实现的通过自动化实现，不能通过自动化实现的，罗列好功能测试点，给到功能测试的人员去测试

### 8.如何批量执行所有的测试用例

被调文件名：

```
test_baiduLink.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from  selenium import webdriver

class BaiduTest(unittest.TestCase):

        @classmethod
        def setUpClass(cls):
            cls.driver = webdriver.Chrome()
            cls.driver.get('https://www.baidu.com/')
            cls.driver.maximize_window()
            cls.driver.implicitly_wait(60)


        @classmethod
        def tearDownClass(cls):
            cls.driver.quit()


        def test_001_BaiduNews(self):
            '''获取百度新闻地址'''
            self.driver.find_element_by_link_text('新闻').click()
            self.assertEqual(self.driver.current_url,'http://news.baidu.com/')
            self.driver.back()
            sleep(3)

        @unittest.skip('进入百度地图部分，无法返回所以跳过')
        def test_002_BaiduMap(self):
            '''获取百度地图地址'''
            self.driver.find_element_by_link_text('地图').click()
            self.assertEqual(self.driver.current_url,'https://map.baidu.com/')
            sleep(5)
            self.driver.back()

        def test_003_BaiduSearch(self):
            '''获取百度搜索是否可以点击'''
            so = self.driver.find_element_by_id('kw')
            self.assertTrue(so.is_enabled())
            sleep(3)

        def test_004_BaiduSearch(self):
            '''获取百度搜索搜索内容是否正确'''
            so = self.driver.find_element_by_id('kw')
            so.send_keys('无涯')
            self.driver.find_element_by_id('su').click()
            '''只要我们在input表单中输入内容，他都在value的属性里面，通过元素定位是找不到这个属性的'''
            self.assertEqual(so.get_attribute('value'),'无涯')
            sleep(3)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

执行调用文件名：

```
test_operateFiles.py
```

内容：

```python
import unittest
import os

def OperateFiles():
  
    '''使用discover方法执行文件中所有的以test开头的模块'''
    discover = unittest.TestLoader().discover(start_dir=os.path.dirname(__file__),
    pattern='test_*.py',
    top_level_dir=None)
    return discover

def Run():
    unittest.TextTestRunner(verbosity=2).run(OperateFiles())

if __name__ == '__main__':
    Run()
```

### 9.如何生成HTML测试报告文件

被调文件名：

```
test_baiduLink.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from  selenium import webdriver

class BaiduTest(unittest.TestCase):

        @classmethod
        def setUpClass(cls):
            cls.driver = webdriver.Chrome()
            cls.driver.get('https://www.baidu.com/')
            cls.driver.maximize_window()
            cls.driver.implicitly_wait(60)


        @classmethod
        def tearDownClass(cls):
            cls.driver.quit()


        def test_001_BaiduNews(self):
            '''获取百度新闻地址'''
            self.driver.find_element_by_link_text('新闻').click()
            self.assertEqual(self.driver.current_url,'http://news.baidu.com/')
            self.driver.back()
            sleep(3)

        @unittest.skip('进入百度地图部分，无法返回所以跳过')
        def test_002_BaiduMap(self):
            '''获取百度地图地址'''
            self.driver.find_element_by_link_text('地图').click()
            self.assertEqual(self.driver.current_url,'https://map.baidu.com/')
            sleep(5)
            self.driver.back()

        def test_003_BaiduSearch(self):
            '''获取百度搜索是否可以点击'''
            so = self.driver.find_element_by_id('kw')
            self.assertTrue(so.is_enabled())
            sleep(3)

        def test_004_BaiduSearch(self):
            '''获取百度搜索搜索内容是否正确'''
            so = self.driver.find_element_by_id('kw')
            so.send_keys('无涯')
            self.driver.find_element_by_id('su').click()
            self.assertEqual(so.get_attribute('value'),'无涯')
            sleep(3)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

执行调用文件名

```
test_operateFiles.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
import sys
import unittest
import os
import HTMLTestRunner

'''
如果是在python2中，一定要加如下代码，如果不加会出现中文enicode error的错误信息
import sys
reload（sys）
sys.setdefaultencoding('utf-8')
'''

'''文件调用方法'''
def OperateFiles():
    discover = unittest.TestLoader().discover(
    start_dir=os.path.dirname(__file__),
    pattern='test_*.py',
    top_level_dir=None)
    return discover

'''文件执行方法'''
def Run():
    # unittest.TextTestRunner(verbosity=2).run(OperateFiles())
    file = os.path.join(os.path.dirname(__file__),'report','testreport.html')
    HTMLTestRunner.HTMLTestRunner(
        stream=open('file','wb'),
        title='UI自动化测试',
        description='中台UI自动化测试详细信息').run(OperateFiles())

if __name__ == '__main__':
    Run()

```

### 10.测试代码覆盖率coverage

使用方法详细参考（可以写个py文件，驱动进行代码覆盖率的测试，不需要老是调用指令）

https://www.cnblogs.com/coderzh/archive/2009/12/01/pythoncoverage.html

https://blog.csdn.net/piapiada/article/details/50624372

# 第九章 Requests库接口测试

## 一.初试request-豆瓣网和拉勾网访问

注意⚠️：post请求里面data是传递基于from表单的数据，json的请求参数是基于json格式请求的字符串

![image-20191125215742795](/Users/apple/Library/Application Support/typora-user-images/image-20191125215742795.png)

```python
'''豆瓣网访问
写了反爬虫，暂时不考虑
'''
import requests
params = {'search_text':'沈强','cat':'1002'}
url = requests.get(url='https://movie.douban.com',params=params)
'''网络协议状态码'''
print(url.status_code)
'''请求正文，返回内容为text格式的字符串'''
print(url.text)
# '''先把test用content转化成二进制，然后编码解码成utf-8'''
# print(url.content.decode('utf-8'))
# '''请求地址'''
# print(url.url)
# '''请求地址的编码'''
# print(url.encoding)
# '''除非确定是json格式的字符串，不然不要使用json方法'''
# # print(url.json())
```

```python
'''
拉勾网爬取数据
Cookie:填写
因为拉勾网写了反爬虫，读出的数据为：
{"status":false,"msg":"您操作太频繁,请稍后再访问","clientIp":"221.224.144.84","state":2402}
'''

import requests
data = {'first':'true','pn':1,'kd':'自动化测试'}
headers = {
    'Accept':'application/json',
    'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
    'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36',
    'Cookie':'*'
   }
'''
verify=False：绕过ssl协议
timeout = 5：预防请求超时
'''
r =requests.post(url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false',data=data,headers=headers,verify=False,timeout = 5)
print(r.text)
```

## 二.访问公司后台

注意⚠️：在物联网的业务中，如果上报信息超时时间不确定，可以使用轮循的方法，每间隔一段时间查找一次，超出总时间就抛出异常

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

'''
注意输入的参数，进行序列化和反序列化
'''
import json
import requests

headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}

'''注意区分post方法里面表单数据使用data，json格式的字符串需要用json'''
data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

r = requests.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                  json=data,
                  headers=headers
                  )
'''公司后台返回的是字符串'''
# print(r.text,type(r.text))
'''
1。调用indent进行格式转换，转换成json格式
2。调用ensure_ascii进行编码转换，unicode编码的汉语转换成utf-8的汉语
'''
print(json.dumps(r.json(),indent=True,ensure_ascii=False))
```

## 三.Cookies的传递（根据公司回传）

```python
'''
注意区分：http协议和websocket协议的区别
http是建立一次链接，当然也可以通过ajax进行轮询，但是效率比较低，会有超时的风险
websocket是和服务器建立双向的持久性链接
'''
import json
import requests

def gitHeaders():
    headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}
    return headers

data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

'''登陆return cookies'''
def  urlTest():
    r = requests.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                      json=data,
                      headers=gitHeaders()
                      )
    return r.cookies

'''调用cookies'''
def getUrlTest():
    get = requests.get(url='http://lyfadmin.edu.laiyifen.com/guide/getBackGuideSetting.do',
                       cookies = urlTest())
    print(json.dumps(get.json(),indent=True,ensure_ascii=False))

getUrlTest()
```

## 四.动态参数获取和token获取

使用json方法，获取对应key的下标，去取对应参数的value，return 给目标函数调用

注意⚠️：这部分的知识怎么运用在取动态参数上。

例如：

```python
返回的数据类型格式为：
{
'start':0,
'msg':'',
'data':{
  'tocken':'1234568'
  ...
}
}

return r.json()['data']['token']
```

## 五.Requests对认证的处理（出现401或403报错）

详细参考我的博客园：https://www.cnblogs.com/shen-qiang/p/11936320.html

```python

'''
什么时候需要对认证做处理：
当请求返回状态码为401或403，且msg为：{"error": "Unauthorized access"}
'''   
import requests 
from requests.auth import HTTPBasicAuth 

r=requests.get( ‘http://localhost:5000/hotel/username/‘, 
auth=HTTPBasicAuth(‘wuya‘,‘admin‘)) 

print (r.text)
```

![image-20191126162423820](/Users/apple/Library/Application Support/typora-user-images/image-20191126162423820.png)

## 六.requests对session的处理

实例化requests.Session()对象，session建立后可以保持cookie的链接，不需要return cookie

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import json
import requests

def gitHeaders():
    headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}
    return headers

data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

'''登陆return session'''
def  urlTest():
    '''实例化session对象'''
    sessionID = requests.Session()
    '''直接调用session'''
    sessionID.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                      json=data,
                      headers=gitHeaders()
                      )
    return sessionID

'''调用session'''
def getUrlTest():
    get = urlTest().get(url='http://lyfadmin.edu.laiyifen.com/guide/getBackGuideSetting.do')
    print(json.dumps(get.json(),indent=True,ensure_ascii=False))

getUrlTest()
```

## 七.Requests对文件的上传和下载

### 1.文件的上传

注意⚠️：上传文件的请求的key和value值需要用单引号阔起来。如果有双引号，需要对参数进行转译，处理起来很麻烦

![image-20191126193737085](/Users/apple/Library/Application Support/typora-user-images/image-20191126193737085.png)

```python
#!/use/bin/env python
#coding:utf-8
#Author:shenqiang

import  requests

'''传递的数据'''
data={
	"upload":"提交",
	"__channel":"renren",
	"privacyParams":'{"sourceControl": 99}',
	'hostid':'967004081',
	'requestToken':'-1124080368',
	'_rtk':'88c0e36a'}

'''上传文件的'''
files = {"file":
	        ("11.jpg", open("/Users/apple/Desktop/11.jpg", "rb"), "image/jpeg",{})}


'''hearders'''
headers={'Conteny-Type':'multipart/form-data',
         'Cookie':'wp_fold=0; jebe_key=2ebfe84a-ba39-4685-a7d4-2c2554a2c332%7Caa130ffbb5d8cc8d315a4ab7b5b427ae%7C1574763933779%7C1%7C1574763934663; jebecookies=bdca1d47-b697-4140-a2e0-ac30c4a5b558|||||; loginfrom=null; ver=7.0; WebOnLineNotice_972956233=1; XNESSESSIONID=abbe86d381c3; id=972956233; societyguester=0b0dfda34622b4fdc5f63d33bc8bbae53; t=0b0dfda34622b4fdc5f63d33bc8bbae53; xnsid=58c37e4b; ick=0a1287c1-023e-4868-bd07-bb96efea9185; ick_login=34b7eeb3-51ed-4d82-9c49-37d953b00269; __utma=151146938.1362702986.1574763700.1574763700.1574763700.1; __utmb=151146938.3.10.1574763700; __utmc=151146938; __utmz=151146938.1574763700.1.1.utmcsr=renren.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmt=1; _de=199FB1745CB4DC6D74D4674661EB8018; _r01_=1; anonymid=k3fpklmh-s0sajh; depovince=ZGQT',
         'User-Aaent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'}

'''文件上传'''
r=requests.post(
	url='http://head2.upload.renren.com/head2/UploadFacade.do?pagetype=customheadupload&hostid=972956233&uploadid=1574764014376',
	data=data,
	headers=headers,
	files=files)

'''上传状态和文本内容'''
print(r.status_code)
print(r.text)

```

### 2.文件的下载(重要！)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

'''
注意：定义类的时候，内部方法之间的互调
步骤：
1.按照流的方式进行下载
2.存储在某个文件中
'''
import requests
import shutil
import time

class DownLoadFile():

    def readyDatas(self):
        '''
        准备数据：固定参数
        :param datas 接口参数
        :param downLoadPath 下载文件地址
        '''
        times = time.strftime("%Y-%m_%d %H_%M_%S", time.localtime(time.time()))

        self.datas = {"username":"lyfadmin","password":"liuhaijun123456","type":1}
        self.downLoadPath = '/Users/apple/Documents/TestCode/tryApiTest/requestsPractice/Files{0}.xlsx'.format(times)

        return self.datas,self.downLoadPath

    def getHearders(self):
        '''
        :return: Hearders 接口报文的头信息
        '''
        self.Hearders = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html',
               'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'}
        return  self.Hearders

    def setSession(self):
        '''
        :return: SessionId 返回网址的Session信息
        '''
        self.readyDatas()
        self.getHearders()
        self.sessionId = requests.Session()
        self.sessionId.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                                  json = self.datas,
                                  headers = self.Hearders)
        return self.sessionId

    def downFiles(self):
        '''
        下载文件
        '''
        self.setSession()
        loginStatus = self.sessionId.get('http://lyfadmin.edu.laiyifen.com/promotion-static/template/coupon.xlsx',
                                         headers = self.Hearders,
                                         stream = True )
        if loginStatus.status_code == 200:
            with open(self.downLoadPath,'wb') as files:
                '''Function1'''
                # for chunk in loginStatus.iter_content(chunk_size=1024):
                #     files.write(chunk)
                '''function2'''
                loginStatus.raw.decode_content = True
                shutil.copyfileobj(loginStatus.raw, files)
            print('file download succeed')
        else:
            print('file download failed')


if __name__ == '__main__':
    DownLoadFile = DownLoadFile()
    DownLoadFile.downFiles()
```

# 第十章数据驱动

## 一.execl数据驱动

### 1.xlutils简要说明

导包：pip3 install xlutils

注意⚠️：xlutils在介些Execl文件的时候，只识别.xls后缀的文件，如果是.xlsx后缀的文件被解析，.xlsx后缀的文件会被破坏

### 2.接口自动化中对execl简单的读取

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

'''xlrd写入文件，同时清空原文件,一般这种方法只用来读'''
import xlrd
import os

'''拿到文件的路径'''
def base_path(filename = None):
    return os.path.join(os.path.dirname(__file__),filename)

'''读取文件内容'''
work = xlrd.open_workbook(base_path('execlTestFile.xls'))

'''以下标或者sheet名取对应的哪页'''
sheet = work.sheet_by_index(0)
# sheet = work.sheet_by_name()

'''查看文件有多少行'''
print(sheet.nrows)

'''获取单元格内容,第3行，第3列'''
print(sheet.cell_value(2,2))
```

### 3.改写execl文件的内容

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import xlrd
import os
from xlutils.copy import copy

'''拿到文件的路径'''
def base_path(filename = None):
    return os.path.join(os.path.dirname(__file__),filename)

'''打开文件'''
work = xlrd.open_workbook(base_path('execlTestFile.xls'))
'''把文件内存存在一个变量里'''
file_content = copy(work)
'''拿到文件需要改写的sheet页'''
file = file_content.get_sheet(0)
# print(file_content)
'''
定位文件位置写入内容
行和列以从0开始数下标
'''
file.write(2,2,'沈强')
'''保存文件，并且重新命名'''
file_content.save(base_path('execlTestFile.xls'))
```

### 4.configparser配置文件的读取（服务和数据库连接）

配置文件名

config.ini

文件内容：

```ini
[linux]
ip:10.0.13.26
port:22
username:root
password:W2ynE6b58wheeFho

[mysql]
ip:10.0.13.26
port:22
username:root
password:W2ynE6b58wheeFho
```

文件名

```python
tryConfigparser.py
```

文件内容

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import os
import configparser

'''拿到文件的路径'''

def base_path(filename=None):
    return os.path.join(os.path.dirname(__file__), filename)

'''函数的默认参数处理'''
def getConfigparser(Linux='linux'):
    '''实例化对象'''
    config = configparser.ConfigParser()
    '''读取文件内容'''
    config.read(base_path('config.ini'))
    ip = config.get(Linux, 'ip')
    port = config.get(Linux, 'port')
    username = config.get(Linux, 'username')
    password = config.get(Linux, 'password')
    return [ip, port, username, password]

print(getConfigparser(),type(getConfigparser()))

# '''遍历文件内容'''
# for i in range(len(getConfigparser())):
#     print(getConfigparser()[i])

```

### 5.mysql常用的一些操作指令

```python
启动MySQL服务
mysql.server start

停止MySQL服务
mysql.server stop

重启MySQL服务
mysql.server restart

进入MySQL数据库
mysql -u root -p
Password: 密文传输（shen6409175）
  
'''查看数据库'''
show databases;
'''选中数据库'''
use students;
'''查看表'''
show tables;
'''创建表'''
create table student(
   id int primary key,
   name varchar(50),
   age varchar(10),
   address varchar(100)
   );
'''查看表结构'''
desc student;
'''查看表设计'''
show create table student;
```

## 二.MySQL数据驱动

### 1.数据库查询

```python
#!/user/bin/env python
# coding:utf-8
# Author:shenqiang
import pymysql

def connectMysql():
    try:
        '''链接数据库'''
        connect = pymysql.connect(
            host='127.0.0.1',
            user='root',
            password='shen6409175',
            db='students'
        )
    except Exception as  e:
        return e.args
    else:
        '''创建游标'''
        cur = connect.cursor()
        '''SQL语句分离'''
        # sql = 'select * from student where id = %s'
        # params = (2,)
        # '''查重'''
        # cur.execute(sql,params)
        # '''单条数据的查询'''
        # data = cur.fetchone()
        # return datas
        sql = 'select * from student'
        '''查重'''
        cur.execute(sql)
        '''多条数据查询'''
        datas = cur.fetchall()
        '''方法一，遍历'''
        # for data in datas:
        #     print(data)
        '''方法二，列表推倒式'''
        db = [data for data in datas]
        return db

    finally:
        # 关闭游标和链接
        cur.close()
        connect.close()

print(connectMysql())
```

### 2.数据库插入数据

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import pymysql

def connectMysql():
    try:
        '''链接数据库'''
        connect = pymysql.connect(
            host='127.0.0.1',
            user='root',
            password='shen6409175',
            db='students'
        )
    except Exception as  e:
        return e.args
    else:
        '''创建游标'''
        cur = connect.cursor()
        '''导入数据'''
        # 单条语句的插入
        # sql = 'insert into student values(%s,%s,%s,%s);'
        # params = (6,'沈～','24','南京')
        '''批量插入数据'''
        sql = 'insert into student values(%s,%s,%s,%s);'
        params = [
            (7, '沈～', '24', '南京'),
            (8, '沈～', '24', '南京')
            ]
        cur.executemany(sql,params)
        '''insert后必须要commit()'''
        connect.commit()
    finally:
        # 关闭游标和链接
        cur.close()
        connect.close()

connectMysql()
```

### 3.数据库删除数据

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import pymysql

def connectMysqlDelect():
    try:
        '''连接数据库'''
        connectMysqlDelect = pymysql.Connect(
            host = '127.0.0.1',
            user = 'root',
            password = 'shen6409175',
            db = 'students',
        )
    except Exception as  e:
        print(e.args)
    else:
        '''创建游标'''
        cur = connectMysqlDelect.cursor()
        '''执行sql'''
        mysql = 'delete from student order by id desc limit 1'
        cur.execute(mysql)
        '''提交事务'''
        connectMysqlDelect.commit()
        print('success')
    finally:
        '''关闭游标和数据库'''
        cur.close()
        connectMysqlDelect.close()

connectMysqlDelect()
```

### 4.一个完整的Mysql数据驱动方式

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import pymysql

class MysqlTry:
    '''链接数据库'''
    def connectMysql(self):
        '''尝试链接数据库'''
        try:
            connect =pymysql.connect(
                host = '127.0.0.1',
                user='root',
                password='shen6409175',
                db='students'
            )
        except Exception as e:
            print(e.args)
        return connect

    def selectMysql(self,sql,params):
        '''创建游标'''
        cur = self.connectMysql().cursor()
        '''查重'''
        cur.execute(sql,params)
        '''查询'''
        result = cur.fetchall()
        '''删除游标'''
        cur.close()
        return result

def checkValid(username,age):
    opera = MysqlTry()
    sql = "select * from student where name = %s and age = %s"
    params=(username,age)
    return opera.selectMysql(sql=sql,params=params)

def checkinfo():
    username = input('请输入用户名 \n')
    age = input('请输入用户年龄 \n')
    result = checkValid(username,age)
    if result:
        '''关闭数据库'''
        MysqlTry().connectMysql().close()
        print('该用户在数据库中，测试通过！')
    else:
        print('该用户不在数据库中，存在bug！')

if __name__ == '__main__':
    checkinfo()
```

## 三.CSV数据驱动

注意⚠️：CSV文件的生成，只有通过文件软件的另存为csv格式才可生成没有异常的文件，千万不可以直接修改文件后缀名。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import csv

'''读取csv文件的方法'''
def ReadCsvlist():
    '''方法一:列表方式取数据'''
    '''通过列表提取csv文件'''
    with open('csvTestFile.csv') as file:
        '''reader是csv的迭代器'''
        reader = csv.reader(file)
        '''跳过首行'''
        next(reader)
        '''列表推倒式'''
        db =  [item for item in reader]
        return db

print(ReadCsvlist(),type(ReadCsvlist()))

#     '''方法二：字典的格式输出csv文档内容'''
#     with open('csvTestFile.csv',encoding='utf-8') as file:
#         reader = csv.DictReader(file)
#         for item in reader:
#             print(dict(item))
#
# ReadCsvlist()
```

## 四.爬取拉勾网实例

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import  csv
import  requests

def getHeaders():
	headers={
		'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
		'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
		'Cookie':'_ga=GA1.2.1237290736.1534169036; user_trace_token=20180813220356-b7e42516-9f01-11e8-bb78-525400f775ce; LGUID=20180813220356-b7e428ad-9f01-11e8-bb78-525400f775ce; index_location_city=%E5%85%A8%E5%9B%BD; _gid=GA1.2.675811712.1540794503; JSESSIONID=ABAAABAAAGFABEF93F47251563A52306423D37E945D2C54; _gat=1; LGSID=20181029213144-fa3c8e13-db7e-11e8-b51c-525400f775ce; PRE_UTM=; PRE_HOST=www.bing.com; PRE_SITE=https%3A%2F%2Fwww.bing.com%2F; PRE_LAND=https%3A%2F%2Fwww.lagou.com%2F; Hm_lvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1539529521,1539785285,1540794503,1540819902; SEARCH_ID=ae3ae41a58d94802a68e848d36c30711; Hm_lpvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1540819909; LGRID=20181029213151-fe7324dc-db7e-11e8-b51c-525400f775ce',
'Referer':'https://www.lagou.com/jobs/list_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88?labelWords=sug&fromSearch=true&suginput=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95'}
	return headers

def laGou(url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false',page=2):
	positions = []
	r = requests.post(
		url=url,
		headers=getHeaders(),
		data={'first': False, 'pn': page, 'kd': '自动化测试工程师'})
	for i in range(15):
		city = r.json()['content']['positionResult']['result'][i]['city']
		education = r.json()['content']['positionResult']['result'][i]['education']
		workYear = r.json()['content']['positionResult']['result'][i]['workYear']
		positionAdvantage = r.json()['content']['positionResult']['result'][i]['positionAdvantage']
		salary = r.json()['content']['positionResult']['result'][i]['salary']
		companyFullName = r.json()['content']['positionResult']['result'][i]['companyFullName']
		positionLables = r.json()['content']['positionResult']['result'][i]['positionLables']
		position = {
			'公司名称': companyFullName,
			'城市': city,
			'学历': education,
			'工作年限': workYear,
			'薪资': salary,
			'工作标签': positionLables,
			'福利': positionAdvantage
		}
		positions.append(position)
	for item in positions:
		print(item)

if __name__ == '__main__':
	for item in range(1, 31):
		laGou(page=item)
```

## 五.DDT测试驱动

注意⚠️：有相同执行步骤的测试用例可以使用ddt

### 1.基本介绍

详细使用方法参考我的博客圆：https://www.cnblogs.com/shen-qiang/p/11954061.html

```python
注意⚠️：以下代码不可执行
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
import  csv
import  requests
import  ddt
import  unittest

url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false'

def getHeaders():
   headers={
      'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
      'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
      'Cookie':'_ga=GA1.2.1237290736.1534169036; user_trace_token=20180813220356-b7e42516-9f01-11e8-bb78-525400f775ce; LGUID=20180813220356-b7e428ad-9f01-11e8-bb78-525400f775ce; index_location_city=%E5%85%A8%E5%9B%BD; _gid=GA1.2.675811712.1540794503; JSESSIONID=ABAAABAAAGFABEF93F47251563A52306423D37E945D2C54; _gat=1; LGSID=20181029213144-fa3c8e13-db7e-11e8-b51c-525400f775ce; PRE_UTM=; PRE_HOST=www.bing.com; PRE_SITE=https%3A%2F%2Fwww.bing.com%2F; PRE_LAND=https%3A%2F%2Fwww.lagou.com%2F; Hm_lvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1539529521,1539785285,1540794503,1540819902; SEARCH_ID=ae3ae41a58d94802a68e848d36c30711; Hm_lpvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1540819909; LGRID=20181029213151-fe7324dc-db7e-11e8-b51c-525400f775ce',   'Referer':'https://www.lagou.com/jobs/list_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88?labelWords=sug&fromSearch=true&suginput=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95'}
   return headers

def f():
   list1=[]
   t=[i for i in range(1,31)]
   list1.append(t)
   return list1

@ddt.ddt
class LaGou(unittest.TestCase):
   @ddt.data((1,),(2,),(3,))
   @ddt.unpack
   def test_laGou(self,page):
      positions = []
      r = requests.post(
         url=url,
         headers=getHeaders(),
         data={'first': False, 'pn': page, 'kd': '自动化测试工程师'})
      self.assertEqual(r.json()['success'],True)
      print(r.json()['content']['positionResult']['result'][0]['city'])

if __name__ == '__main__':
   unittest.main(verbosity=2)
```

### 2.DDT的简单应用

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

from ddt import data,unpack,ddt
import unittest

@ddt
class MyDdtTest(unittest.TestCase):

    @data((1,1),(2,2),(3,3))
    @unpack
    def test_ddt(self,value1,value2):
        print('实际参数{0},预期参数{1}'.format(value1,value2))
        print(self.assertEqual(value1,value2))

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

## 六.对XML文件的读取

XML文件格式

![image-20191129212515675](/Users/apple/Library/Application Support/typora-user-images/image-20191129212515675.png)

XML文件读取方法

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import xml.dom.minidom

# def dirverXml(value=None):
#     '''取得单节点的数据'''
#     xmlFile = xml.dom.minidom.parse('data.xml')
#     db = xmlFile.documentElement
#     itemList = db.getElementsByTagName(value)
#     item = itemList[0]
#     return item.firstChild.data
#
# print(dirverXml('admin'))

def dirverXmlName(parent=None,child = None):
    '''取得单节点的数据内容'''
    xmlFile = xml.dom.minidom.parse('data.xml')
    db = xmlFile.documentElement
    itemList = db.getElementsByTagName(parent)
    item = itemList[0]
    return item.getAttribute(child)

print(dirverXmlName('WuYA','nick'))
```

## 七.测试执行的log读取

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import  logging
from selenium import  webdriver
import  unittest

def log(log_content):
    # 定义文件
    logFile = logging.FileHandler('log.md', 'a',encoding='utf-8')
    # log格式
    fmt = logging.Formatter(fmt='%(asctime)s-%(name)s-%(levelname)s-%(module)s:%(message)s')
    logFile.setFormatter(fmt)

    # 定义日志
    logger1 = logging.Logger('', level=logging.DEBUG)
    logger1.addHandler(logFile)
    logger1.info(log_content)

class Ui(unittest.TestCase):
    def setUp(self):
        self.driver=webdriver.Chrome()
        log('初始化浏览器')

    def test_001(self):
        log('开始测试')
        pass

    def tearDown(self):
        log('测试结束')
        self.driver.quit()

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

# 第十一章 接口测试框架设计应用与案例实战

## 一.如何进行数据分离(⚠️)

自动化测试纬度：1.功能上的UI自动化测试 、2.接口上的API自动化测试 、3.单元层的自动化测试

自动化测试的难点：如何进行数据分离

分离的数据有哪些:   url 请求头 请求参数  请求方法

分离的数据处理方法：

- 1.放入数据库，需要执行sql（需要大量的sql，而且服务器有问题数据会有影响）
- 2.放入文件中（Excel、CSV、config、XML），最好通过execl，需要往文件写入测试结果
  - 注意⚠️面临的问题：
    - 对于请求参数很多的接口，Excel文件修改接口请求信息比较麻烦（通过读取json文件处理）
    - 脚本维护成本
    - 接口自动化测试执行效率
    - json文件中True、False和Null的处理需改改成'true'、'false'、''
- 3.动态参数的处理
  - 形式参数参数化

## 二.API自动化构建测试框架的维度

- 目录优化
- 数据分离
- 获取json文件内容
- 关联excel与json的请求参数
- 对POST请求的二次封装
- 编写测试用例
- 增加断言
- 重构代码
- 当请求参数是动态参数的处理
- 参数关联业务处理
- 关联参数写入文件
- 检测headers函数
- 测试结果写入文件
- 统计测试成功率
- 新增发送邮件功能
- 针对平台加密数据处理

## 三.自动化测试框架设计案例（首页测试搜索命中率）

其中包含：登录，session传递，同义词、近义词、关联商品、复杂商品搜索、热词搜索，历史搜索。

## 四.以拉勾网为例子，进行API自动化测试例子

详细代码参考：https://github.com/ShenQiangTestLovers/TestCode/tree/master/lagouAPITest

## 五.针对平台加密数据处理

接口自动化需求和问题：

“1.对请求参数按照key-value的格式，进行参数名的ascill码排序

- 请求参数不确定
- 怎么排序

2.在第一步的结果字符串尾部拼接密钥

- name=shenqiang&age=28&address=nanjing&sex=boy+密钥

3.排序后，对请求的参数进行MD5加密“

- hashlib



解决方法（思路）

1.请求参数不确定--->动态参数 *args，**kwargs

2.怎么排序--->			sorted()

3.请求地址尾部密钥拼接可以用urllib的parse

4.hashlib加密

```python
from urllib import parse
import hashlib

def dataSign(secure='shenqiang',*args,**kwargs):
    '''对字典的key进行排序'''
    dict2 = dict(sorted(kwargs.items(),key=lambda item:item[0]))
    '''对url进行拼接'''
    str1 = parse.urlencode(dict2)+secure
    '''进行MD5加密'''
    # 实例化MD5
    md = hashlib.md5()
    md.update(str1.encode('utf-8'))
    return md.hexdigest()

'''data2参数不确定'''
data2 = {"a":"2","c":"1","b":"3"}

print(dataSign(**data2))
```

# 第十二章 持续集成(CI)

## 一.Jenkins安装

详情参考：https://blog.csdn.net/liqing0013/article/details/83930419

## 二.插件的安装

步骤：1.点击系统管理

​			2.点击管理插件：http://localhost:8080/jenkins/pluginManager/

​			3.必须安装的插件

​					Ant									-->jmerter测试工具使用

​					Checkstyle						--->检测代码

​					Cobertura						----->代码覆盖率

​					Email Extension				---->发送邮件	

​					Git										----->仓库托管

​					HTML Publisher				------>生成html报告

​					Violations plugin				------>输出违规报告

​					xUnit plugin						----->单元测试报告

​					svn										------>可用可以不用

​					Performance						----->性能测试报告插件



## 三.邮件的配置

1.点击系统管理

2.点击系用设置:http://localhost:8080/jenkins/configure

3.邮件配置

- 系统管理员邮件地址必须填写
- 邮件通知
  - java：
    - maven自动打成.war
    - 把.war放到tomcat的webapps目录下
    - 重新启动tomcat服务

![image-20191206153810979](/Users/apple/Library/Application Support/typora-user-images/image-20191206153810979.png)

![image-20191206154017674](/Users/apple/Library/Application Support/typora-user-images/image-20191206154017674.png)

## 四.Global Tool配置

Global Tool Configuration配置：
1、点击系统管理
2、点击	Global Tool Configuration
3、必须配置：
   jdk
   git
   ant
   maven
   注意事项:指定jdk,git,ant的安装路径,git特别注意，要制定到具体的git.exe路径



## 五.git详细应用

1、git安装好之后，建议按照git的管理客户端工具:TortoiseGit
2、密钥的生成:
   ssh-keygen -t rsa -C "wuya@outlook.com"  gitlab  
   git config --global user.name "wuya"
   git config --global user.email "wuya@outlook.com"

   查看是否配置好：
   git config --list 

   git init-->初始化
   git add .-->提交文件
   git commit -m "备注信息"
   git push--->把本地的代码提交到服务器 (github)
   git pull-->把服务器的代码与本地代码同步

   两点：
   1、注册github账号，把本地的代码提交到github
   2、配置你的ide开发工具  提交代码



## 六.jmeter的jenkins的整合

![image-20191206203331683](/Users/apple/Library/Application Support/typora-user-images/image-20191206203331683.png)

![image-20191206203532954](/Users/apple/Library/Application Support/typora-user-images/image-20191206203532954.png)

![image-20191207161422417](/Users/apple/Library/Application Support/typora-user-images/image-20191207161422417.png)

![image-20191207161454125](/Users/apple/Library/Application Support/typora-user-images/image-20191207161454125.png)

## 七.Allure环境配置

1. 安装allure的插件
2. 配置安装allure步骤：
  A.系统管理
  B.Global Tool Configuration
  C.找到Allure Commandline安装，点击后,进行安装,建议选择2.4.1版本
  D.点击保存
3.配置allure的保存
  A.系统管理
  B.系统设置
  C.最后找到Allure Report后，进行配置：
    key:WORKSPACE(不可以更改)
	value:D:/git/Python/Four/report
  D.点击保存
4.执行后，生成allure的测试报告:
  A.打开job的配置
  B.增加构建后操作步骤中的Allure Report
  C.填写report
5.安装如下python第三方的库：
   pip  install pytest 
   pip  install pytest-allure-adaptor
6. 安装第五点的第三方的库成功之后，在构建步骤中填写如下的信息：
	cd D:/git/github/irainui/testCase
	d:
	python -m pytest  --alluredir ${WORKSPACE}/report
7.执行后，生成allure的测试报告

官方地址：https://docs.qameta.io/allure/

安全策略：
1.系统管理
2.Configure Global Security

测试用例的执行：
1、编写了UI的自动化
2、接口的测试用例
需求：
先执行接口后自动执行UI的测试用例
具体：先UI后Jmetet4.0

## 八.定时任务（crontabs）

1.配置失败增加邮件通知

2.定时任务的讲解

3.多个工程的进行

4.安全策略的配置

5.接口的持续监控

### 定时任务：

安装命令：

crontab -l

yum install crontabs 

命令格式如下：

![image-20191207214820971](/Users/apple/Library/Application Support/typora-user-images/image-20191207214820971.png)

![image-20191207214916806](/Users/apple/Library/Application Support/typora-user-images/image-20191207214916806.png)

### 构建失败邮件通知

![image-20191207215700750](/Users/apple/Library/Application Support/typora-user-images/image-20191207215700750.png)

### Jenkins中工程上下联动执行

执行顺序：

1.接口测试用例执行

2.UI自动化测试用例

3.手工执行：没覆盖到的场景+新的功能点+验证失败的自动化测试用例

注意⚠️：通过配置构建触发器，在API自动化测试后，进行UI自动化测试

![image-20191207221742053](/Users/apple/Library/Application Support/typora-user-images/image-20191207221742053.png)

### 实现本地与CI服务器的远程构建

1.本地完善编写测试脚本

2.把编写的测试脚本调试通过后，提交到git

3.CI构建的过程是怎么样的？

- 把最新的代码从Git服务器获取到更新到CI平台（一般CI构建在云服务或者公司自己的服务器上）
- 在CI的终端执行测试脚本

注意⚠️：git上有两个密钥，一个提供给本地用于提交源码，另一个提供给jenins服务用于CI的远程构建

### Jenkins可能遇到的问题

#### 1.新的jenkins已经取消了默认的账户，导致安装插件成功后，点击继续使用，或出现空白页面，或者推出后，登录账号后不知道以哪个登录，遇到该问题，解决方案如下：



Linux终端：

1.停止tomcat的运行

2.删除.jenkins的文件夹（root的根目录），删除命令为：

cd

rm -rf  .jenkins/

3.在tomcat的webapps目录下，删除jenkins的目录

4.重新启动tomcat

5.安装插件

6.切换创建用户，该创建的用户就是管理员的账户

7.创建的账户登录jenkins就可以了



#### 2.IDE正常执行，但是CI执行的时候，提示XX模块不存在

把缺失的模块加到path中，代码：

```python
import sys
page_path = os.path.join(os.path.dirname(os.path.dirname(__file__)),'page')
sys.path.append(page_path)
```

#### 3.IDE中提示XX模块不存在

方法同2

#### 4.Allure生成不了测试报告

Pytest高版本导致的，可以安装pytest==4.0.2版本

## 九.GitLab环境搭建