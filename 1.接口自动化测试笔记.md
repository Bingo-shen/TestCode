# 简介

## 需要核心掌握的部分：

面向对象：继承和封装（包括类的继承、类的方法、类的封装）

python高级用法：包含列表推导式，匿名函数，三目运算，装饰器，闭包，拆包

函数返回值的处理

Unitttest测试框架和测试套件的的使用

Requests库

精通Postman和Jmeter测试工具(引导开发进行自测，发送测试报告)

# 第一章python基础知识

## 一.python基本方法

注意⚠️:python3.exe是python的解释器，其本质是打开文件，把文件的内容加载到内存中，在内存中的代码执行运行起来后，反馈给终端的用户,python3输入的内容都默认为字符串类型的。

### 1.str的基本方法

```python
'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'
```

```python
name = "沈强"
age = 28
print("我的名字叫{0},我的年龄{1}".format(name,age))
print("我的名字叫%s，我的年龄%d"%(name,age))
print("我的名字叫{name}，我今年{age}岁".format(name=name,age=age))
```

### 2.list的基本方法(列表推导式)

```python
'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'
```

```python
list1 = [1,2,3,4,5,2,3,0,8]
list2 = [3,3,3]
# print(dir(list1))
list1.append(99)
print(list1)
list1.insert(0,22)
print(list1)
count1 = list1.count(2)
print(count1)
print(list1.index(4))
list1.remove(0)
print(list1)
list1.pop()
print(list1)
list1.extend(list2)
print(list1)
list1.reverse()
print(list1)
list1.sort()
print(list1)
for i in  list1:
    if i >= 3:
        print(i)
print([x+1 for x in list1])
print([x+1 for x in list1 if x>3])
```

### 3.dict的基本方法

```python
'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'
```

```python
tuple1 = (1,23,4,["shenqiang","28"],{"name":"shenqiang","age":"28"})
tuple1[3][1] = "29"
print(tuple1)
tuple1[4]["name"] = "沈强"
print(tuple1)
print(dir(tuple1))

dict1 = {'name':'shenqiang','age':'28'}
dict2 = {'adress':'nanjing'}
dict1.update(dict2)
print(dict1)
dict3 = dict1
print(dict3)
print(sorted(dict3.items(),key=lambda item:item[0]))
print(dir(dict1))
# dict1.clear()
# print(dict1)
dict1['name'] = '沈强'
print(dict1)
print(dict1.get('age'))

for key in dict1.keys():
    print(key)

for key,value in  dict1.items():
    print(key,value)
```

### 4.python的书写规范

```python
1.python的单引号和双引号注意区分
2.python的注释方法‘’‘’‘’和#的区别
3.python的str/dict/list的特点
4.注意python对缩进的严格要求
```

### 5.编码和解码

![image-20190730113608505](/Users/apple/Library/Application Support/typora-user-images/image-20190730113608505.png)

注意⚠️:python3默认的编码方式是unicode编码，如果注释里面有说明则是utf-8的编码，在 Python 3 中，字符串和 Unicode 是一家人，而且还是标准，字节流转换为字符串需要解码，字符串转化为字节流需要编码



### 6.数据类型转换

```python
# 字符串和列表之间的类型转换
str = '9,6'
list1 = str.split(',')
print(list1)
str1 = ','.join(list1)
print(str1)
print(type(str1))
```

```python
#字典转化成列表
dict1 = {'name':'shenqiang','age':18}
dict1_list = list(dict1.keys())
dict1_list1 = list(dict1.values())
print(dict1_list)
print(dict1_list1)

# 列表转化成字典
list_dict1 = dict(enumerate(dict1_list))
list1_dict1 = dict(enumerate(dict1_list1))
print(list_dict1)
print(list1_dict1)
```



## 二.python中的函数

### 1.函数的特点

```python
函数：函数是一段可以重复调用的代码，通过输入参数返回结果
名字绑定的机制，把实际参数和形式参数的名称绑定在一起
1.函数调用的时候实际参数的顺序和形式参数的顺序一一对应
2.当函数被调用的时候，指定了形式参数的实际参数，这个时候并不是一一对应的，而是根据指定的值来确定的
```

### 2.函数的参数类型（函数返回值，处理token和session）

```python
1.形式参数
2.实际参数
3.默认参数
4.动态参数（如何分离动态参数）：使用万能函数
def TryTest（*args，**kwargs）
```

```python
'''
需求：
1.对请求的参数进行ascill码排序
2.排序后，对请求的参数进行MD5加密
'''
# 排序
dict1 = {"name":"shenqiang","age":28,"datas":{"name":"shenqiang","age":28}}

def Data(**kwargs):
    return dict(sorted(kwargs.items(),key=lambda item:item[0]))

print(Data(**dict1))
```

### 3.变量类型

```python
1.全局变量
2.局部变量
3.global
```

### 4.匿名函数lambda和三目运算等（高级用法）

```python
'''
匿名函数：
lambda
'''
def Add(a,b):
    print(a+b)
Add(2,3)

per = lambda a,b:a+b
print(per(2,3))
```

```python
'''
三目运算
'''
a = 20
print("True") if a >10 else print("False")
```

```python
'''
匿名函数+三目运算
'''
login = lambda username,password:print('登录成功') if username == 'shenqiang' and password =='123' else print('登录失败')

login('shenqiang','123')
```

```python
'''
匿名函数，字典的排序
'''
data = lambda **kwargs:dict(sorted(kwargs.items(),key=lambda item:item[0]))
print(data(name='shenqiang',age = 28))
```

```python
'''函数的内部函数map(),对列表内的同样元素做同样的事情'''
list1 = [1,23,4,5,6]

print(list(map(lambda x:x+100,list1)))
```

```python
'''函数的内部函数filter(),对列表内的元素进行过滤'''
list2 = [1,2,3,4,5,6]
print(list(filter(lambda a:a>1,list2)))
```

### 5.装饰器（高级用法）

```python
'''
封闭：对已经实现功能的代码尽量不去修改
开放：对现有功能的代码进行拓展
需求：在调用f or f1 先打印getInfo，再打印f
'''
def getInfo(func):
    def info():
        print("无涯自动化测试")
        func()
    return info

@getInfo
def f():
    print("网易云平台")

@getInfo
def f1():
    print("51CTO平台")

f()

'''
步骤：
1.当我们执行getInfo时候,把被装饰的f当作参数传递
2.getInfo函数的返回值会重新赋值
3.一旦结合了装饰器，调用f函数的时候，实际调用了info内部分函数，原来的f1被覆盖
4。被装饰的f重新赋值给装饰器的info
'''
def login(func):
    def inner(Token):
        if Token == "01293":
            return func(Token)
        else:
            print("登录失败")
    return inner

@login
def profile(Token):
    print("登录成功")

profile("01293")
```

### 6.函数实战(登录注册)

```python
'''
需求：要求注册账户，注册后的账户登录系统后，显示登录的昵称
'''
def inout():
    username = input("请输入用户名：")
    password = input("请输入密码：")
    return username,password


def register():
    '''注册用户'''
    username,password = inout()
    temp = username + '|' + password
    with open("user.md", 'w') as  f:
        f.write(temp)


def login():
    '''登录用户'''
    username, password = inout()
    with open('user.md', 'r') as  f:
        temp = f.read()
    info = temp.split("|")
    if username == info[0] and password == info[1]:
        return True
    else:
        return False


def getNick(func):
    '''如果登录成功，获取用户昵称'''
    with open('user.md', 'r') as  f:
        temp = f.read()
    info = temp.split("|")
    if func:
        print('{0}恭喜您登录成功！'.format(info[0]))
    else:
        print("登录失败，请重新登录")


if __name__ == '__main__':
    while True:
        count = eval(input("1.注册，2.登录,3.退出系统"))
        if count == 1:
            register()
        elif count == 2:
            getNick(login())
        elif count == 3:
            import sys
            sys.exit(1)
        else:
            print("输入有误，请重新输入！")
            continue
```

## 三.python中包和模块

### 1.python三方库的安装和卸载

```python
python安装selenium的命令：pip install selenium==2.56.4
python卸载selenium的指令：pip unstall selenium==2.56.4
如果失败请参考百度，选择适应本地安装方式（可能存在本地有py2和py3两种情况，请把pip.exe创建快捷方式，重命名来区分）
```

### 2.python导包

```
导入包的语句：import 包名
导入包中的某个模块时 from 包名 import 模块1,模块2，模块3（如果所有请用通配符*）
注意⚠️：每一个py文件都是一个模块
```



# 第二章HTTP/HTTPS协议详解

## 一.HTTP的完成请求流程



![image-20190402144415761](/Users/apple/Library/Application Support/typora-user-images/image-20190402144415761.png)

```python
区分：URI（统一资源标识符）和URL（统一资源定位符）
熟记：200(请求成功)，302（重定向），400（请求错误），401(未授权)，403（禁止访问），404（未找到资源），500（内部服务错误），502(错误网关、无效网关)，504（网关超时）
注意⚠️：区分协议状态码和接口的响应状态码的区别

```

### 1.Cookie流程图

Cookie明文传输，存储在客户端；

session是密文传输且有时效性，存储在服务端；

token是移动端每次登录成功后，服务端随机生成的32位的字符串，且这个字符串是作为参数在body里面传递的。

![image-20190402145132195](/Users/apple/Library/Application Support/typora-user-images/image-20190402145132195.png)

### 2.Session流程图

![image-20190402145200376](/Users/apple/Library/Application Support/typora-user-images/image-20190402145200376.png)

### 3.Token流程图

![image-20190402145225335](/Users/apple/Library/Application Support/typora-user-images/image-20190402145225335.png)



## 二.HTTPS的完成请求流程

![image-20190402150000995](/Users/apple/Library/Application Support/typora-user-images/image-20190402150000995.png)



```python
注意⚠️：抓包工具charles的破解，配置（获取安全证书，抓取https协议的请求，配置抓取移动端的请求）
```

### 4.其他（Apache、Nginx和websocket协议）

Apache和Nginx工作原理，参考我的博客：https://www.cnblogs.com/shen-qiang/p/11934668.html

websocket协议工作原理，参考我的博客：https://www.cnblogs.com/shen-qiang/p/11934567.html



# 第三章Postman测试工具实战

## 一.接口测试是测什么

### 1.接口测试参数

```python
业务状态码
msg
data
```

### 2.断言数据类型

```python
1.协议状态码
2.业务状态码
3.数据断言
```



## 二.Postman实现自动化测试

### 1.自动化测试核心

```python
公共数据分离，减少代码的冗余，减少依赖关系，尽可能做到高内聚，低耦合.
```

### 2.Postman中的测试用例

```python
Postman中每一个Collections-->集合-->多个TestSuite，每一个TestSuite覆盖了一个场景下的多个接口测试case，所以每一个Collection集群了一个场景化的测试case
```

### 3.Postman中断言js的套用写法

```javascript
/*注意这个是在Tests下进行断言*/
/*序列化的处理*/

var jsonData=JSON.parse(responseBody)

/*验证协议状态码*/

pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

/*验证业务状态码*/

tests['验证业务状态码']=jsonData.code === 0

/*验证data里面的id是否等于1*/

tests['验证data里面的id值是否为1']=jsonData.data.id === 1

/*获取动态参数token
  postman中调用变量的方式{{token}}
*/
if(jsonData.data.token)
{
  tests['获取token成功']=true
  postman.setEnviromentVariable('token',jsonData.data.token);
}
else
  {
    tests['获取token失败']=false
  }

/*获取动态参数*/

 postman.setEnviromentVariable('ecouponID',jsonData.data.self_coupon[0].id;
```



### 4.接口测试的四个维度

```python
1.字段边界值的验证(一般中小厂，无严格要求，所以不需要测试)
2.字段为空的验证
3.字段类型的验证
4.基于业务的形式--->业务流程场景化是OK的  前后端的请求是OK的  
```

### 5.如何生成HTML报告

步骤一：在Collections下面选中需要生成HTML的Collection，点击Export

![image-20190402200038035](/Users/apple/Library/Application Support/typora-user-images/image-20190402200038035.png)步骤二：选中Export

![image-20190402200147762](/Users/apple/Library/Application Support/typora-user-images/image-20190402200147762.png)步骤三：文件重命名存入对应文档里

![image-20190402200252988](/Users/apple/Library/Application Support/typora-user-images/image-20190402200252988.png)步骤四：执行.json脚本

其中cd到文件的根目录，new run 执行文件名进行接口测试



![image-20190402201036290](/Users/apple/Library/Application Support/typora-user-images/image-20190402201036290.png)

![image-20190402205053553](/Users/apple/Library/Application Support/typora-user-images/image-20190402205053553.png)

步骤五 找到html报告的位置

![image-20190402210514257](/Users/apple/Library/Application Support/typora-user-images/image-20190402210514257.png)



# 第四章常用库的介绍

## 一.常见的time库

```python
import time as t

'''获得时间戳'''
print(int(t.time()))

'''获得年月日'''
print(t.localtime(t.time()))

'''获得易读的年月日'''
print(t.strftime('%y-%m-%d %H:%M:%S',t.localtime()))
```

## 二.常见的os库

```python
import os

'''调用计算机系统的指令'''
print(os.system('ifconfig'))

'''创建文件夹'''
os.mkdir('/Users/apple/Desktop/log')

# '''删除文件夹'''
# os.rmdir('/Users/apple/Desktop/log')

'''文件重命名'''
os.rename('/Users/apple/Desktop/log','/Users/apple/Desktop/Newlog')

'''当前文件所在路径'''
print('当前目录在哪个路径下',os.path.dirname(__file__))

'''当前文件所在路径的上一级路径'''
print('当前文件所在路径的上一级路径',os.path.dirname(os.path.dirname(__file__)))

'''当前文件所在路径的上一级路径的上一级路径'''
print('当前文件所在路径的上一级路径的上一级路径',os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

'''当前文件的全路径'''
print(__file__)

'''拿到文件的上级目录'''
base_dir = os.path.dirname(os.path.dirname(__file__))

'''拼接login文件里面的内容'''
file1 = open(os.path.join(base_dir,'login'),'r')

'''输出读取的文件内容'''
print(file1.read())

'''关闭文件'''
file1.close()

'''当一个接口的参数个数未知'''
def f(*args,**kwargs):
    return kwargs

'''返回的是一个字典'''
print(f(age='18',address='nanjing'))

print(f(name='shenqiang',age='18',address='nanjing'))
```

## 三.sys库/hashlib中MD5加密和导包异常处理

```python
'''
python库:
1.标准库
2.第三方库
3.自定义库
sys：
1。变量
2。常用的方法
3。sys
'''
#
import sys
#
# # print(sys.argv)
# # 第一种常用方式
# if sys.argv[1] == 'sleep':
#     print("sleep")
# else:
#     print('end')

# print(dir(sys))
# print(sys.platform)
# print(sys.version)

for item in sys.path:
    print(item)

```

![image-20191106103735176](/Users/apple/Library/Application Support/typora-user-images/image-20191106103735176.png)

```python
#当导入的模块无法识别的时候，通过以下方式把模块加入环境变量
# '''拼接文件到某个目录'''
base_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)),'Fs')
# # #把fs加到环境变量
sys.path.append(base_dir)
# '''遍历环境变量'''
for item in sys.path:
    print(item)
```

```python
from urllib import parse
import hashlib

'''
MD5加密：
1。对请求的参数进行ascill码排序 ---> dict(sorted(dict1.items(),key=lambda item:item[0]))
2。对url 进行encode编码  --->datas = parse.urlencode(req)
3。做MD5加密   生成sign(密钥) --->     MDfive = hashlib.md5()
                        MDfive.update(datas.encode('utf-8')
                        return MDfive.hexdigest()
'''
def MD5(**kwargs):
    req = dict(sorted(kwargs.items(), key=lambda item: item[0]))
    datas = parse.urlencode(req)
    MDfive = hashlib.md5()
    MDfive.update(datas.encode('utf-8'))
    return MDfive.hexdigest()

print(MD5(name = 'shenqiang',age = '28'))
```



## 四.dict/list/tuple的序列化和反序列化

```python
import json

'''
数据：
  序列化dumps：把python的数据类型转化成str的类型的过程
  反序列化loads：反序列化就是把str的数据类型转化成python的数据类型结构(字典或者列表)
文件：
	序列化dump：把内容写到文件中
	反序列化load：把文件的内容读取出来
'''

'''字典的序列化和反序列化'''
dict_str = {'name':'shenqiang','age':18,'address':'shanghai'}

#序列化，字典转化成字符串
str_dict = json.dumps(dict_str)

print(str_dict,type(str_dict))

#反序列化，字符串转化成字典
dict_str = json.loads(str_dict)

print(dict_str,type(dict_str))


'''列表的序列化和反序列化'''
list_str = ['shenqiang','18','nanjing']

#列表序列化
str_list = json.dumps(list_str)

print(str_list,type(str_list))

#列表反序列化
list_str = json.loads(str_list)

print(list_str,type(list_str))


'''元祖的序列化和反序列化,会转变成列表'''
tuple_str = ('shenqiang','20','nanjing')

#元祖的序列化
str_tuple = json.dumps(tuple_str)

print(str_tuple,type(str_tuple))

#元祖的反序列化
tuple_str = json.loads(str_tuple)

print(tuple_str,type(tuple_str))
```

## 五.接口自动化序列化和反序列化实例

要点：	1.返回参数的序列化和反序列化

​		    2.文件内容的编码和解码	

```python
import json
import requests

# '''请求来伊份后台地址'''
# base_url = requests.post(url='',data={},deaders ={})
#
# '''输出网络状态码'''
# print(base_url.status_code)
#
# '''输出返回的参数'''
# print(base_url.text,type(base_url.text))
#
# '''如果输出的text是str格式的文件,需要序列化和反序列化'''
# r = json.loads(base_url.text)
# print(r,type(r))

'''向天气预报发起请求'''
r = requests.get(url='http://www.weather.com.cn/data/sk/101190408.html')

# '''把编码成utf-8'''
# 读取requests方法输出的数据：print(r.content.decode('utf-8'))

'''对文件进行序列化-->把服务的响应写入某个文件中'''
json.dump(r.content.decode('utf-8'),open('weather.json','w',encoding='utf-8'))

'''
对文件进行反序列化，获取读取文件的内容
1.文件反序列化后是unicode类型
2.进行编码，把unicode类型转换成str类型
3.然后使用反序列化，把str类型转换成字典
'''

load = json.load(open('login.json','r'))

print(load,type(load))

'''对str类型文件内容进行反序列化，读取city的value'''
city = json.loads(load)['weatherinfo']['city']

print('查询的城市是：',city)
```

## 六.实例：将序列化和反序列化应用于登陆注册系统

```python
# #!/usr/bin/env python
# # -*- coding: utf-8 -*-
# # @Time : 2019-11-04 22:10
# # @Author : shenqiang
# # @File : TryLogin.py
# # @Software: PyCharm

import  json

'''
需求：要求注册账户，注册后的账户登录系统后，显示登录的昵称
'''
def inUserName():
    '''
    :param username:用户名
    :return username:用户名
    '''
    username = input("请输入用户名：")
    return username

def inPassWord():
    '''
    :param password:密码
    :return password:密码
    '''
    password = input("请输入密码：")
    return password

def register():
    '''注册用户'''
    username,password = inUserName(),inPassWord()
    temp = username + '|' + password
    json.dump(temp,open('user.md','w'))

def login():
    '''登录用户'''
    username, password = inUserName(),inPassWord()
    temp = json.load(open('user.md','r'))
    info = temp.split("|")
    if username == info[0] and password == info[1]:
        return True
    else:
        return False

def getNick(func):
    '''如果登录成功，获取用户昵称'''
    temp = json.load(open('user.md', 'r'))
    info = temp.split("|")
    if func:
        print('{0}恭喜您登录成功！'.format(info[0]))
    else:
        print("登录失败，请重新登录")

if __name__ == '__main__':
    while True:
        try:
            count = eval(input("1.注册，2.登录, 3.退出系统"))
            if isinstance(count,float):
                count = int(count)
        except Exception as  e:
            print(e.args)
        else:
            if count == 1:
                register()
            elif count == 2:
                getNick(login())
            elif count == 3:
                import sys
                sys.exit(1)
            else:
                print("输入有误，请重新输入！")
                continue

```

# 第五章 Python文件和异常的处理

## 一.异常知识

### 1.异常处理的格式

```python
try:
    div1(a,b)
except Exception as E:
    print(E.args)
```

### 2.异常处理的Body

```python

'''
执行顺序：
try(如果执行成功)，先执行try，再执行else代码，最后执行finally
try(如果执行失败)，先执行except代码，最后执行finally
'''
def TestTry(self):
    try:
        if self == '1':
            print('try')
        else:
            print('false')
    except:
        print('except')
    else:
        print('else')
    finally:
        print('finally')

TestTry("1")
```



### 3.异常的类型

| 异常名称                  | 描述                                               |
| :------------------------ | :------------------------------------------------- |
|                           |                                                    |
| BaseException             | 所有异常的基类                                     |
| SystemExit                | 解释器请求退出                                     |
| KeyboardInterrupt         | 用户中断执行(通常是输入^C)                         |
| Exception                 | 常规错误的基类                                     |
| StopIteration             | 迭代器没有更多的值                                 |
| GeneratorExit             | 生成器(generator)发生异常来通知退出                |
| StandardError             | 所有的内建标准异常的基类                           |
| ArithmeticError           | 所有数值计算错误的基类                             |
| FloatingPointError        | 浮点计算错误                                       |
| OverflowError             | 数值运算超出最大限制                               |
| ZeroDivisionError         | 除(或取模)零 (所有数据类型)                        |
| AssertionError            | 断言语句失败                                       |
| AttributeError            | 对象没有这个属性                                   |
| EOFError                  | 没有内建输入,到达EOF 标记                          |
| EnvironmentError          | 操作系统错误的基类                                 |
| IOError                   | 输入/输出操作失败                                  |
| OSError                   | 操作系统错误                                       |
| WindowsError              | 系统调用失败                                       |
| ImportError               | 导入模块/对象失败                                  |
| LookupError               | 无效数据查询的基类                                 |
| IndexError                | 序列中没有此索引(index)                            |
| KeyError                  | 映射中没有这个键                                   |
| MemoryError               | 内存溢出错误(对于Python 解释器不是致命的)          |
| NameError                 | 未声明/初始化对象 (没有属性)                       |
| UnboundLocalError         | 访问未初始化的本地变量                             |
| ReferenceError            | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |
| RuntimeError              | 一般的运行时错误                                   |
| NotImplementedError       | 尚未实现的方法                                     |
| SyntaxError               | Python 语法错误                                    |
| IndentationError          | 缩进错误                                           |
| TabError                  | Tab 和空格混用                                     |
| SystemError               | 一般的解释器系统错误                               |
| TypeError                 | 对类型无效的操作                                   |
| ValueError                | 传入无效的参数                                     |
| UnicodeError              | Unicode 相关的错误                                 |
| UnicodeDecodeError        | Unicode 解码时的错误                               |
| UnicodeEncodeError        | Unicode 编码时错误                                 |
| UnicodeTranslateError     | Unicode 转换时错误                                 |
| Warning                   | 警告的基类                                         |
| DeprecationWarning        | 关于被弃用的特征的警告                             |
| FutureWarning             | 关于构造将来语义会有改变的警告                     |
| OverflowWarning           | 旧的关于自动提升为长整型(long)的警告               |
| PendingDeprecationWarning | 关于特性将会被废弃的警告                           |
| RuntimeWarning            | 可疑的运行时行为(runtime behavior)的警告           |
| SyntaxWarning             | 可疑的语法的警告                                   |
| UserWarning               | 用户代码生成的警告                                 |

## 二.接口测试简介

### 1.接口测试的维度

```python
'''
接口测试的纬度：
1.边界值测试（一般大型公司测试）
2.参数为空
3.参数类型
4.业务测试
自动化的范畴：
安全      性能
业务纬度测试：
1.功能接口自动化测试
    关注：
    1.用户操作流程
2.接口自动化测试
    关注：
    1.JS代码不能出问题
    2.前后端交互没有问题
    3.场景化/流程/逻辑不能出问题
    4.高频的用户场景
'''
```

## 三.文件的操作

### 1.文件操作的通用方式

问题：可能会忘记 close file，导致内存泄漏

```python
import json

'''
open的参数：
1.要操作的文件名称
2.以什么样的方式操作文件：
r：只读模式
w：只写模式【不可读，不存在就创建，存在就清空文件内容】
x：只写模式【不可读，不存在就创建，存在就报错】
a：增加模式【可读，不存在就创建，存在只增加里面的内容】
'+'表示可以同时读写某个文件，比如：
r+：读写
w+：写读
X+：写读
a+：写读
'''
file1 = open('file.json','w+')
temp = {
'name':'shenqiang',
'age':18,
'address':'nanjing'
}
# # for line in temp:
# #     file1.write(line)
# file1.writelines(temp)
# file1.close()

'''文件的序列化'''
json.dump(temp,open('file.json','w+'))
```

### 2.文件操作的优化方案

使用with，系统会自动帮助关闭文件，防止内存溢出

```python
'''文件的上下文的处理'''
with open('Test1','w+') as T:
    T.write('这种操作方式可以系统帮助关闭，可以避免很多问题，会自动close，避免内存泄漏')
```

# 第六章python的面向对象详解

## 一.OOP是什么？

### 1.OOP的定义

python3和python2的映射区别

```python
f2 = f()
f1 = f()
print(id(f1))
print(id(f2))
    python3的一个对象，映射关系是同一个id。python2的对象，每次调用都会新生成一个地址
```

```python
'''
类：是由一些属性和方法组成的
'''
def f():
    pass

''' 
对象的创建--->类的事例化过程
三个特性：
1.对象的句柄--->区分不同的对象
2.属性
    共有属性
				类属性（共同的属性分离出来）：属于类也属于对象
        实例属性：只属于对象
        局部变量
    私有属性
3.方法  
'''
class Person(object):
    '''类属性'''
    gongtong = ‘China’
    def __init__(self,name,age):
        '''实例属性'''
        self.name = name
        self.age = age

    def getName(self):
        return self.name

    def getAge(self):
        return self.age

    def setName(self,name):
        self.name = name

    def setAge(self,age):
        self.age = age

 		def info(self):
        return 'name:{0},age:{1}'.format(self.name,self.age)

# 实例化Person
per = Person('shenqiang','28')
per2 = Person('lll','20')
print(per.getName(),per.getAge())

per2.setAge('10')
per2.setName('shen')
print(per2.getAge(),per2.getName())

pel = Person('沈强',18)
print(pel.getAge(),pel.getName())
print(pel.info())
```

### 2.构造函数

```python
'''
满足所有人类的个性，调用万能参数
构造函数：即使没写构造函数，类都是有构造函数的
一个类可以有多个构造函数，建议一个类只有一个构造函数
构造函数用来：
1.初始化属性
'''
class Person(object):
    def __init__(self,**kwargs):
        self.kwargs = kwargs

    def getInfo(self):
        print(list(self.kwargs.values()))

per = Person(name='shenqiang',age = '28')
per.getInfo()
```

### 3.析构函数

任何情况下都会最后执行析构函数

```python
'''析构函数的执行顺序：
对象实例化->构造函数->对象调用方法->代码跳转到具体的方法->执行方法的代码块->最后执行析构函数
'''
class person(object):
    def __init__(self):
        print('我是构造函数')

    def __del__(self):
        print('我是析构函数')

    def info(self):
        print('我是方法')
#实例化方法
per = person()
#调用方法
per.info()
```

## 二.OOP方法讲解

```python
'''
属于类：
    类属性
    静态方法
    类方法
属于对象：
    实例属性
    普通方法
    特性方法
'''
```

### 1.普通方法

```python
'''
普通方法
    动态方法（万能参数）
特性方法

'''

class Person():

    def cnn(self):
        pass

    def f1(self,*args,**kwargs):
        self.args = args
        self.kwargs = kwargs

    def info(self):
        print('这是个普通的方法')

per = Person()
per.info()
```

### 2.特性方法

```python
'''
特性方法：
不能有形式参数
被调用的时候不要加（）
'''
class person(object):
    '''特性方法调度@property'''
    @property
    def getUserId(self):
        pass

per = person
per.getUserId
```

### 3.静态方法

```python
'''
静态方法：直接使用类名进行调用，它属于类
对象可以直接调用静态方法，一般不建议这么做
'''
class MYSQL(object):
    '''静态方法，直接提供给全局调用'''
    @staticmethod
    def cnn():
        return '静态方法'

print(MYSQL.cnn())
```

### 4.类方法

```python
'''
类方法：直接使用类来调用
所有的用例在执行的时候只执行一次
'''
class Person(object):

    @classmethod
    def cnn(cls):
        pass
```

### 5.方法说明

​	方法用来描述对象所具有的行为，例如，列表对象的追加元素、插入元素、删除原宿、排序，字符串对象的分隔、连接、排版、替换、烤箱的温度设置、烘烤，等等

　　在类中定义的方法可以粗略分为四大类：公有方法、私有方法、静态方法和类方法。公有方法、私有方法一般是指属于对象的实例方法，其中私有方法的的名字以两个下划线（__）开始。每个对象都有自己的公有方法和私有方法，在这两类方法中都可以访问属于类和对象的成员；公有方法通过对象名直接调用，私有方法不能通过对象名直接调用，只能在实例中通过self调用，或在外部通过Python支持的特殊方式来调用.

　　类的所有实例方法都必须至少有一个名为self的参数，并且必须是方法的第一个形参（如果有多个形参的话），self参数代表对象自身。在类的实例方法中访问实例属性时需要以self为前缀，但在外部通过对象名调用对象方法时，并不需要传递这个参数，如果在外部通过类名调用属于对象的公有方法，需要显式为该方法的self参数传递一个对象名，用来明确指定访问哪个对象的数据成员。

　　静态方法和类方法都可以通过类名和对象名调用，但不能直接访问属于对象的成员，只能访问属于类的成员。一般将cls作为类方法的第一个参数，表示该类自身，在调用类方法时不需要为该函数传递值。

## 三.继承

### 1.类属性的继承

```python
'''
继承：重用已有的数据和方法，减少代码的重复编写
子类继承父类所有的实例变量和方法
'''
# 类属性的继承
class Person(object):

    address = '地球'

class UsaPerson(Person):
    pass

per = UsaPerson()
print(per.address)
```

### 2.实例属性的继承（super方法）

```python
'''实例属性的继承和继承的两种方法'''
class Fruit(object):

    def __init__(self,name):
        self.name =name

'''由于业务需求，子类继承父类的实例属性'''
class Apple(Fruit):

    def __init__(self,name,brand,color):
        '''子类继承父类的两种方式'''
        Fruit.__init__(self,name)
        # super(Apple,self).__init__(name)
        self.brand = brand
        self.color = color

    def info(self):
        return('我是水果{0},我的的品牌是{1}，我是{2}色的'.format(self.name,self.brand,self.color))

apple = Apple('banana','baiguoyuan','yellow')
print(apple.info())


'''由业务需求，子类不继承父类的实例属性'''

class apple(Fruit):

    def __init__(self,brand,color):
        self.brand = brand
        self.color = color

    def info(self):
        return('我的的品牌是{0}，我是{1}色的'.format(self.brand,self.color))

apple = apple('baiguoyuan','yellow')
print(apple.info())
```

### 3.方法的继承

#### 单继承

```python
'''
方法的继承：
1.子类为什么重写父类的方法：子类要有自己的特性
当子类重写父类的方法后，对子类进行实例化，子类调用的方法（父类/子类）都存在，执行的方法是子类的方法（从下到下）

单个类继承的原则：
1。子类继承了父类，但是子类没有重写父类的方法，使用的是父类的方法（从上而下）
2。子类继承了父类，但是子类重写了父类的方法，使用的是子类的方法，子类优先使用自己的方法（从上而下）
'''
class Fruit(object):

    def eat(self):
        print ('水果是可以吃的')


class Apple(Fruit):
    def __init__(self,color):
        self.color = color
    '''重写了eat方法'''
    def eat(self):
        print('水果的颜色是：{0}'.format(self.color))

class Banana(Apple):
    def eat(self):
        print('myname is banana')

apple = Apple('yellow')
apple.eat()

# 需要一个对象，可以给个空对象
Banana('').eat()
```

#### 多继承

```python
'''
多个类继承：
1.从左到右
2.同级继承，跨级会报错
3.优先调用自己的函数
⚠️延伸:新式类（object）C3算法（广度优先）和经典类（深度优先）
'''
class Person(object):
    def eat(self):
        print('Person need eat')

class Mother(Person):
    def eat(self):
        print('her is like eat fruit')

class Father(Person):
    def eat(self):
        print('hi is like eat Vegetables')

class Son(Father,Mother):
    pass

son = Son()
son.eat()
```

### 4.登陆实战案例

```python
import json
import sys

class Login(object):
    def __init__(self,username,password):
        self.username = username
        self.password = password

    def getUsername(self):
        return self.username

    def setUsername(self,username):
        self.username = username

    def getPassword(self):
        return self.password

    def setPassword(self,password):
        self.password = password

    def register(self):
        '''
        注册
        '''
        temp = self.username+'|'+self.password
        '''改写，序列化和反序列化'''
        json.dump(temp,open('login', 'w'))
        print('恭喜你注册成功！')

    def login(self):
        f = str(json.load(open('login', 'r')))
        list1 = f.split('|')
        if list1[0] == self.username and list1[1] == self.password:
            return True
        else:
            return False

    def userInfo(self):
        '''改写，序列化和反序列化'''
        f = str(json.load(open('login', 'r')))
        list1 = f.split('|')
        '''验证用户等登陆是否成功'''
        r = self.login()
        if r:
            print('登陆成功！用户昵称为：{0}'.format(list1[0]))
        else:
            print('登陆失败！请检查您的账号和密码！')

    def Exit(self):
        sys.exit('')
        print('您已退出该系统!')

r = Login('shenqiang','shen111')
def main():
    while True:
        try:
            t = int(input('1。注册；2。登陆;3。退出登陆 \n'))
        except Exception as e:
            print(e.args)
        else:
            if t == 1:
                r.register()
            elif t == 2:
                r.userInfo()
            elif t == 3:
                r.Exit()
            else:
                print('输入错误，请重新输入！')
        finally:
            pass

if __name__ == '__main__':
    main()
```

### 5.工厂模式（包含_ _call_ _ _,_ _ _str_ _ _,_ _ _doc_ _）



```python
'''__call__:当函数调用__call__，函数内部生成的是静态方法'''
class New(object):
    def __call__(self, *args, **kwargs):
        print('我是一个静态方法')

new = New().__call__()
```

注意：_ _str_ _的方法使用

```python
'''
__str__：对象代表的含义，返回一个字符串，通过它可以把字符串和对象关联起来，方便某些程序的实现，该字符串表示了某个类，实现__str__后，可以直接使用print输出对象，也可以用str触发__str__的执行
__doc__：打印出类的注释
1.对象的意思
2.返回一个字符串，把字符串和对象关联起来-->该字符串表示这个对象
'''

class Try(object):
    '''这事一个类'''
    def __str__(self):
        print(self.__doc__)

try1 = Try().__str__()

'''工厂模式'''

class Factory(object):
    def CreateFruit(self,Fruit):
        if Fruit == 'apple':
            return Apple()
        elif Fruit == 'banana':
            return Banana()

class Fruit():
    def __str__(self):
        return 'Fruit'

class Apple():
    def __str__(self):
        return 'apple'

class Banana():
    def __str__(self):
        return 'banana'

if __name__ == '__main__':
    factory = Factory()
    print(factory.CreateFruit('apple'))
    print(factory.CreateFruit('banana'))
```

# 第七章 Jmeter实现接口自动化测试

## 一.Jmeter的插件安装和HTTP请求格式

### 1.Jmeter插件安装

插件名：jmeter-plugins-manager

用途：管理和安装其他插件

所在路径：/Applications/apache-jmeter-5.1.1/lib/ext/

安装插件名：JSON/YAML Plugins（json支持插件）

​			PerfMon（性能测试插件）

​			WebSocket*（WebSocket相关接口）



### 2.HTTP请求格式

层级关系：

测试计划

​	查看结果树

线程组

​	简单控制器

​		HTTP信息头管理

​		HTTP请求

## 二.Jmeter正则表达式

### 1.正则表达式测试地址

http://tool.oschina.net/regex/

### 2.动态参数的获取方法

Tocken的正则表达式模版：

![image-20190413165314648](/Users/apple/Library/Application Support/typora-user-images/image-20190413165314648.png)

Token的json格式调用

![image-20190413174539515](/Users/apple/Library/Application Support/typora-user-images/image-20190413174539515.png)

## 三.断言的内容和方式

接口测试需要验证：

1.协议状态码

2.响应内容

3.业务状态码

4.数据断言

断言方式：

使用json插件断言，可以指定字段的位置，跟随业务和前段进行测试，响应断言没有目标位置，可能代码结构存在异常



![image-20190413195517684](/Users/apple/Library/Application Support/typora-user-images/image-20190413195517684.png)

## 三.ant和build.xml文件配置

### 1.ant安装和build.xml基础配置

```python
测试报告步骤：
1.搭建ant环境(path的环境变量)
cmd的命令提示符输入ant or ant - v
2、jmerer的目录C:\apache - jmeter - 4.0\extras下找到ant - jmeter - 1.1
.1.jar, 把它copy到ant的apache - ant - 1.10
.0\lib下
3、打开jmeter的bin目录下的jmeter.properties文件，做如下修改:
把jmeter.save.saveservice.output_format = csv
修改为jmeter.save.saveservice.output_format = xml

4、编写build.xml文件
A.执行测试脚本
B.生成测试报告(html)
C.自动发送邮件
5、执行, 执行命令：
cd C:\apache - jmeter - 4.0\TestSuite
c:
ant
```

### 2.自动发送邮件配置

```python
自动发送邮件问题总结：
1、自动发送邮件，需要三个jar，分别是：activation.jar,
commons - email - 1.2.jar, mail.jar, 这三个文件放在ant的lib目录下
2、Exception reading response timeout stack jire -->JRE
3、auhtoration, 401, 403

Jmerer加到环境变量的步骤：
1.创建JMETER_HOME, 加C:\apache - jmeter - 4.0
2.CLASSPATH里面加:
CLASSPATH = % JMETER_HOME %\lib\ext\ApacheJMeter_core.jar; % JMETER_HOME %\lib\jorphan.jar;
3.path环境变量里面加:
% JMETER_HOME % / bin;
4.jmeter测试
```

### 3.jmeter性能报告的生成

```python
Jmeter生成性能测试报告
1.修改配置文件jmeter.properties(或者不需要修改，直接是默认的)
  jmeter.save.saveservice.output_format = csv
2.到脚本目录下
cd C:\apache - jmeter - 4.0\TestSuite\script
3.直接执行

jmeter -n -t MiddleStageTest.jmx -l MiddleStage.jtl -e -o /Applications/apache-jmeter-5.1.1/TestSuite/report/jtl_report/

3.注意⚠️：每次执行清空生成的文件（包含隐藏文件），删除script下的logo和jtl文件
模板的定制：
C:\apache - jmeter - 4.0\bin\report - template
```

### 4.premon插件的应用

```python
permon(监控服务器CPU，I/O，内存等)插件的应用：
1.下载permon的插件
2.下载ServerAgent - 2.2.1, 并且解压
3.监听器中添加permon
4.启动serverAgent的插件, 监听端口的4444
5.点击默认点击localhost(也就是本机)

查询所有端口的占用情况：
sudo lsof -i -P | grep -i "listen"

查询某端口是否被占用：
sudo lsof -i :3306
  
终止某个端口的程序：
sudo kill 716

linux系统的状态统计
top指令观察系统里面的资源占用信息
其中：PID：进程ID VIRT虚拟内存的大小 RES物理内存大小 SHR共享内存大小  %MEM内存占用比例 %CPU CPU占用比例 

top | grep sys*
```

## 四.解析基于Jmeter的性能测试报告

Jmeter性能测试报告：

**图表信息详解**

测试报告分为两部分，Dashboard和Charts，下面分开解析。

**1、Dashboard（概览仪表盘）**

**①、Test and Report informations**

![image-20191115091439121](/Users/apple/Library/Application Support/typora-user-images/image-20191115091439121.png)

**②、APDEX (应用性能指标)**

关于APDEX的相关信息，请参考这里：[应用性能指标](http://oneapm.udesk.cn/hc/articles/515)；英文原文，参考这里：[Apdex-Wikipedia](https://en.wikipedia.org/wiki/Apdex)

![image-20191115091507151](/Users/apple/Library/Application Support/typora-user-images/image-20191115091507151.png)

**③、Requests Summary**

![image-20191115091535814](/Users/apple/Library/Application Support/typora-user-images/image-20191115091535814.png)

**2、Charts（详细信息图表）**

**PS：**由于详细信息图表有点多，这里我挑几个性能测试过程中比较关键的图表解析！

**Over Time**

**①、Response Times Over Time（脚本运行期间的响应时间变化趋势图）**

说明：可以根据响应时间和变化和TPS以及模拟的并发数变化，判断性能拐点的范围。

![image-20191115091352582](/Users/apple/Library/Application Support/typora-user-images/image-20191115091352582.png)

**②、 Response Time Percentiles Over Time (successful responses)**

说明：脚本运行期间成功的请求响应时间百分比分布图，可以理解为聚合报告里面不同%的数据，图形化展示的结果。

![image-20191115091648608](/Users/apple/Library/Application Support/typora-user-images/image-20191115091648608.png)

**③、Bytes Throughput Over Time（脚本运行期间的吞吐量变化趋势图）**

说明：在容量规划、可用性测试和大文件上传下载场景中，吞吐量是很重要的一个监控和分析指标。

![image-20191115091716145](/Users/apple/Library/Application Support/typora-user-images/image-20191115091716145.png)

**④、 Latencies Over Time（脚本运行期间的响应延时变化趋势图）**

说明：在高并发场景或者强业务强数据一致性场景，延时是个很严重的影响因素。

![image-20191115091743687](/Users/apple/Library/Application Support/typora-user-images/image-20191115091743687.png)

**Throughput**

**①、Transactions Per Second（每秒事务数）**

说明：每秒事务数，即TPS，是性能测试中很重要的一个指标，它是用来衡量系统处理能力的一个重要指标。

![image-20191115091815594](/Users/apple/Library/Application Support/typora-user-images/image-20191115091815594.png)

**Response Times**

**①、 Response Time Percentiles（响应时间百分比分布曲线图）**

说明：即响应时间在某个范围内的请求在所有请求数中所占的比率，相比于平均响应时间，这个值更适合用来衡量系统的稳定性。

![image-20191115091844739](/Users/apple/Library/Application Support/typora-user-images/image-20191115091844739.png)

**②、Time Vs Threads（平均响应时间和线程数的对应变化曲线）**

说明：可以通过这个对应的变化曲线来作为确定性能拐点的一个参考值。

![image-20191115091911313](/Users/apple/Library/Application Support/typora-user-images/image-20191115091911313.png)

**3、添加所需监听器，导入日志文件即可查看**
在性能测试过程中，我们往往需要将测试结果保存在一个文件当中，也可以为日后的性能测试报告提供更多的素材

在Jmeter中，结果都存放在 **.jtl**文件中，格式有很多种，可以根据需要进行更爱，选择某个监听器，在**configure页面**进行相应配置，让我们来查看下保存后的文件有哪些内容：

![img](https://upload-images.jianshu.io/upload_images/5999951-d59ad56615a379cf.png?imageMogr2/auto-orient/strip|imageView2/2)

- timeStamp：请求发出的绝对时间
- elapsed：响应时间
- label：HTTP请求名称
- responseCode：请求返回码
- responseMessage：请求返回消息
- threadName：请求所属的线程名称
- dataType：数据类型
- success：是否成功
- failureMessage：失败信息
- bytes：字节
- sentBytes：发送字节数
- grpThreads：
- allThreads：
- Latency：延迟
- IdleTime：思考时间
- Connect：连接

接下来添加一个聚合报告，然后导入日志文件，查看结果，还可以添加其他的监听器，操作方法一样

![img](https://upload-images.jianshu.io/upload_images/5999951-d36ef092f83624ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

PS：如果测试计划中增加了监听器（生成概要结果），在执行命令时就可以看到每个线程的执行情况

![img](https://upload-images.jianshu.io/upload_images/5999951-ce26bf722b4a823f.png?imageMogr2/auto-orient/strip|imageView2/2)

**PS：设置好线程数、循环次数、集合点、事务、断言、关联等等后即可执行压力测试**

### 最后，大并发下还是需要进行分布式性能测试

原理和LR的agent差不多，因为jmeter由Java开发，耗内存、cpu，所以需要采用分布式

步骤：
1、关闭防火墙
2、在所要运行jmeter并作为负载生成器的机器上安装jmeter（确保在所有系统中使用了相同版本号的Jmeter和jdk）
**PS：目标服务器需要在相同网段，确保Jmeter可以访问目标服务器**
3、确定其中一台机器作为主controller，其他的机器作为agent，然后运行所有agent机器上的jmeter-server文件
4、在controller机器的jmeter中bin目录下，找到jmeter.properties文件，添加节点IP，修改localhost为压力机IP

![img](https://upload-images.jianshu.io/upload_images/5999951-5064d29acf74fb67.png?imageMogr2/auto-orient/strip|imageView2/2)

5、启动conttoller机子上的jmeter应用，选择菜单【运行】---远程启动来分别启动agent，也可以直接选择【远程全部启动】来将所有个agent启动

**在性能测试过程中，我们通常需要将测试结果保存在一个文件当中，既可以保存测试结果，也可以为日后的性能测试报告提供更多的素材**

**Jmeter中，结果都存放在.jtl文件，一般以csv文件格式记录，只需要选择某个监听器，点击页面的configure按钮，建议勾选如下项：Save Field Name，Save Assertion Failure Message**

## 五.性能测试分析方法

#### 1.用户登录并发测试（性能测试通过）

![image-20191108175726213](/Users/apple/Library/Application Support/typora-user-images/image-20191108175726213.png)

![image-20191108182631455](/Users/apple/Library/Application Support/typora-user-images/image-20191108182631455.png)

![image-20191108182659766](/Users/apple/Library/Application Support/typora-user-images/image-20191108182659766.png)

![image-20191108182724199](/Users/apple/Library/Application Support/typora-user-images/image-20191108182724199.png)

![image-20191108182748531](/Users/apple/Library/Application Support/typora-user-images/image-20191108182748531.png)

![image-20191108182815628](/Users/apple/Library/Application Support/typora-user-images/image-20191108182815628.png)

![image-20191108182900011](/Users/apple/Library/Application Support/typora-user-images/image-20191108182900011.png)

#### 2.用户登录业务量测试（性能测试通过）

![image-20191108183356616](/Users/apple/Library/Application Support/typora-user-images/image-20191108183356616.png)

![image-20191108183513453](/Users/apple/Library/Application Support/typora-user-images/image-20191108183513453.png)

![image-20191108183536218](/Users/apple/Library/Application Support/typora-user-images/image-20191108183536218.png)

![image-20191108183600960](/Users/apple/Library/Application Support/typora-user-images/image-20191108183600960.png)

![image-20191108183633929](/Users/apple/Library/Application Support/typora-user-images/image-20191108183633929.png)

**业务量思考时间和等待时间去除，需要再次测试**。

#### **3.随机购物并发测试（测试不通过）**

**响应时间**

![image-20191108193636242](/Users/apple/Library/Application Support/typora-user-images/image-20191108193636242.png)

**APDEX**

![image-20191108193716757](/Users/apple/Library/Application Support/typora-user-images/image-20191108193716757.png)

**业务成功率**

![image-20191108193811022](/Users/apple/Library/Application Support/typora-user-images/image-20191108193811022.png)

**并发数**

![image-20191108193843004](/Users/apple/Library/Application Support/typora-user-images/image-20191108193843004.png)

**资源使用情况**

![image-20191108193949449](/Users/apple/Library/Application Support/typora-user-images/image-20191108193949449.png)

图形分析：

1.从资源使用情况上看，内存正常，CPU明显异常

性能分析：

CPU上升常见原因

1.程序算法异常

2.调用外部接口API的程序

3.CPU配置不高，运算低

4.系统程序不支持多线程

内存使用偏高常见原因：

1.内存泄漏，内存用完，没有得到及时释放

2.内存对象，处理上一场（垃圾过多，内存回收效率低）

3.内存不足（需要增加内存）



![image-20191108194735587](/Users/apple/Library/Application Support/typora-user-images/image-20191108194735587.png)

![image-20191108194813605](/Users/apple/Library/Application Support/typora-user-images/image-20191108194813605.png)

![image-20191108195131660](/Users/apple/Library/Application Support/typora-user-images/image-20191108195131660.png)

#### 4.随机购物业务量测试(测试不通过)

需求：![image-20191108195535915](/Users/apple/Library/Application Support/typora-user-images/image-20191108195535915.png)

执行结果分析：

![image-20191108195609061](/Users/apple/Library/Application Support/typora-user-images/image-20191108195609061.png)

系统资源趋势图：

![image-20191108195642665](/Users/apple/Library/Application Support/typora-user-images/image-20191108195642665.png)

性能测试分析：

通过日志发现，异常原因是数据库异常，需要开发人员排查

# 第八章单元测试框架 unittest

## 一.单元测试框架的组成和职能

### 1.单元测试框架的关系

![image-20190415103133074](/Users/apple/Library/Application Support/typora-user-images/image-20190415103133074.png)

### 2.单元测试框架的组成和职能 

TestCase：单元测试中最小纬度的行为

TestFixure：执行测试前准备的工作（打开浏览器/关闭浏览器，打开/关闭数据库等）

TestSuite：TestCase的集合，用来集合所有的TestCase，可以看作一种容器

TestRunner：测试的执行，先到模块，再到类，到对应模块，再到TestCase。用来运行测试，收集测试数据，呈现给用户

TestReport：测试报告（可视化测试数据）

### 3.单元测试现有的问题

1.国内大多数企业测试驱动模型没有定义

2.哪些是主要测试，哪些做简单的测试，哪些不需要测试，哪些需要做性能测试等等

## 二.Unittest内容

### 1.测试固件和特点

​	a.setUp&tearDown:有多少个test setUp&tearDown就执行多少次

​	b.setUpClass&tesrDownClass：

​	c.程序执行的顺序

​	d.测试用例的编写方式

### 2.输出方式（verbosity）

- 0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共100个 失败20 成功80
- 1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”
- 2 (详细模式):测试结果会显示每个测试用例的所有相关的信息

### 3.Unittest实现webdriver事例

#### 小技巧：如何提高浏览器访问的效率：地址配置给host

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep
from selenium import webdriver

'''
调用类方法，只执行一次setup和teardown
self.diver.back() 每次动作后返回到操作前
test_001_baidu_news通过控制最前面的数字控制执行顺行(默认通过ASCLL编排执行顺序)
'''
'''使用浏览器打开'''

class F2(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.dirver = webdriver.Chrome()
        cls.dirver.maximize_window()
        cls.dirver.get("https://www.baidu.com/")
        cls.dirver.implicitly_wait(30)

    @classmethod
    def tearDownClass(cls):
        cls.dirver.quit()

    '''百度首页链接测试'''
    def test_001_baidu_news(self):
        '''首页链接测试：验证新闻的链接'''
        self.dirver.find_element_by_link_text("新闻").click()
        sleep(2)
        self.dirver.back()

    def test_002_baidu_map(self):
        '''首页链接测试：验证贴吧的链接'''
        self.dirver.find_element_by_link_text("贴吧").click()
        sleep(2)
        self.dirver.back()

    '''百度首页搜索测试'''
    def test_003_baidu_search(self):
        '''首页搜索：搜索webdirver'''
        self.dirver.find_element_by_id('kw').send_keys('webdirver')
        self.dirver.back()

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

### 4.测试套件（TestSuite⚠️）

能够输出对应的test 下的问题

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from selenium import webdriver

'''
调用类方法，只执行一次setup和teardown
self.diver.back() 每次动作后返回到操作前
'''
class BaiduTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')

    @classmethod
    def tearDownClass(cls): 
        cls.diver.quit()

    def test_baidu_001(self):
        '''测试点击新闻后是否会跳转'''
        self.diver.find_element_by_link_text('新闻').click()
        self.diver.back()
        sleep(5)

    def test_baidu_002(self):
        '''测试点击贴吧后是否会跳转'''
        self.diver.find_element_by_partial_link_text('贴吧').click()
        # self.diver.back()
        sleep(5)

if __name__ == '__main__':
    # unittest.main(verbosity=2)
    '''按照模块运行'''
    suite = unittest.TestSuite(unittest.makeSuite(BaiduTest))
    unittest.TextTestRunner(verbosity=2).run(suite)
    
    '''加载整个测试类'''
    suite = unittest.TestLoader().loadTestsFromTestCase(BaiduTest)
    unittest.TextTestRunner(verbosity=2).run(suite)
    
    '''加载整个模块'''
    suite = unittest.TestLoader().loadTestsFromModule('模块名.py')
    unittest.TextTestRunner(verbosity=2).run(suite)
```

### 5.TestSuite公共参数分离

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from selenium import webdriver

class Baidu_Search(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')

    @classmethod
    def tearDownClass(cls):
        cls.diver.quit()

    def test_link(self):
        self.diver.find_element_by_id('kw').send_keys('无涯')
        sleep(5)

    '''静态方法分离'''
    @staticmethod
    def suite():
        suite = unittest.TestLoader().loadTestsFromModule('U_test.py')
        return suite

if __name__ == '__main__':
    '''执行某个模块的测试'''
    unittest.TextTestRunner(verbosity=2).run(Baidu_Search.suite())
```

### 6.分离测试固件（核心掌握分离思想）

1.目录结构

![image-20190416152330575](/Users/apple/Library/Application Support/typora-user-images/image-20190416152330575.png)

2.调用方法

![image-20190416152403017](/Users/apple/Library/Application Support/typora-user-images/image-20190416152403017.png)

3.语法内容

```
Test_Head.py 被调文件
```

```python
import unittest
from selenium import webdriver

class TestHead(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.diver = webdriver.Chrome()
        cls.diver.maximize_window()
        cls.diver.implicitly_wait(30)
        cls.diver.get('https://www.baidu.com')


    @classmethod
    def tearDownClass(cls):
        cls.diver.quit()
```

```
BuiltinMethod.py 调用文件
```

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

from time import sleep
from base.Test_Head import *

def add(a,b):
    return  a-b

class Baidu_Search(TestHead):

    @unittest.skip("忽略这条测试用例")
    def test_link(self):
        self.diver.find_element_by_id('kw').send_keys('无涯')
        self.diver.back()
        sleep(5)

    def test_News(self):
        self.diver.find_element_by_link_text('新闻').click()
        sleep(5)
        
    '''期待运行失败的用例'''
    @unittest.expectedFailure
    def test_004(self):
        self.assertEqual(add(2,3),1)

    '''静态方法分离'''
    @staticmethod
    def suite():
        suite = unittest.TestLoader().loadTestsFromModule('U_test.py')
        return suite

if __name__ == '__main__':
    '''执行某个模块的测试'''
    unittest.TextTestRunner(verbosity=2).run()
```

### 7.unittest断言和断言方法

![image-20190416160352711](/Users/apple/Library/Application Support/typora-user-images/image-20190416160352711.png)

调用6中分离的公共模块，断言代码

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
from base.Test_Head import *

class BaiduTitle(TestHead):

    def test_BaiduTitleTest(self):
        self.assertEqual(self.diver.title,'百度一下，你就知道')

    def test_Baidukw(self):
        so = self.diver.find_element_by_id('kw')
        self.assertTrue(so.is_enabled(),True)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

##### 注意⚠️（确保API自动化和UI自动化的价值）：

1.如何提升API自动化和UI自动化的价值（权威化TestCase）

2.如何确保测试出来的false，直观化，一定不能断言失误

3.能通过自动化实现的通过自动化实现，不能通过自动化实现的，罗列好功能测试点，给到功能测试的人员去测试

### 8.如何批量执行所有的测试用例

被调文件名：

```
test_baiduLink.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from  selenium import webdriver

class BaiduTest(unittest.TestCase):

        @classmethod
        def setUpClass(cls):
            cls.driver = webdriver.Chrome()
            cls.driver.get('https://www.baidu.com/')
            cls.driver.maximize_window()
            cls.driver.implicitly_wait(60)


        @classmethod
        def tearDownClass(cls):
            cls.driver.quit()


        def test_001_BaiduNews(self):
            '''获取百度新闻地址'''
            self.driver.find_element_by_link_text('新闻').click()
            self.assertEqual(self.driver.current_url,'http://news.baidu.com/')
            self.driver.back()
            sleep(3)

        @unittest.skip('进入百度地图部分，无法返回所以跳过')
        def test_002_BaiduMap(self):
            '''获取百度地图地址'''
            self.driver.find_element_by_link_text('地图').click()
            self.assertEqual(self.driver.current_url,'https://map.baidu.com/')
            sleep(5)
            self.driver.back()

        def test_003_BaiduSearch(self):
            '''获取百度搜索是否可以点击'''
            so = self.driver.find_element_by_id('kw')
            self.assertTrue(so.is_enabled())
            sleep(3)

        def test_004_BaiduSearch(self):
            '''获取百度搜索搜索内容是否正确'''
            so = self.driver.find_element_by_id('kw')
            so.send_keys('无涯')
            self.driver.find_element_by_id('su').click()
            '''只要我们在input表单中输入内容，他都在value的属性里面，通过元素定位是找不到这个属性的'''
            self.assertEqual(so.get_attribute('value'),'无涯')
            sleep(3)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

执行调用文件名：

```
test_operateFiles.py
```

内容：

```python
import unittest
import os

def OperateFiles():
  
    '''使用discover方法执行文件中所有的以test开头的模块'''
    discover = unittest.TestLoader().discover(start_dir=os.path.dirname(__file__),
    pattern='test_*.py',
    top_level_dir=None)
    return discover

def Run():
    unittest.TextTestRunner(verbosity=2).run(OperateFiles())

if __name__ == '__main__':
    Run()
```

### 9.如何生成HTML测试报告文件

被调文件名：

```
test_baiduLink.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import unittest
from time import sleep

from  selenium import webdriver

class BaiduTest(unittest.TestCase):

        @classmethod
        def setUpClass(cls):
            cls.driver = webdriver.Chrome()
            cls.driver.get('https://www.baidu.com/')
            cls.driver.maximize_window()
            cls.driver.implicitly_wait(60)


        @classmethod
        def tearDownClass(cls):
            cls.driver.quit()


        def test_001_BaiduNews(self):
            '''获取百度新闻地址'''
            self.driver.find_element_by_link_text('新闻').click()
            self.assertEqual(self.driver.current_url,'http://news.baidu.com/')
            self.driver.back()
            sleep(3)

        @unittest.skip('进入百度地图部分，无法返回所以跳过')
        def test_002_BaiduMap(self):
            '''获取百度地图地址'''
            self.driver.find_element_by_link_text('地图').click()
            self.assertEqual(self.driver.current_url,'https://map.baidu.com/')
            sleep(5)
            self.driver.back()

        def test_003_BaiduSearch(self):
            '''获取百度搜索是否可以点击'''
            so = self.driver.find_element_by_id('kw')
            self.assertTrue(so.is_enabled())
            sleep(3)

        def test_004_BaiduSearch(self):
            '''获取百度搜索搜索内容是否正确'''
            so = self.driver.find_element_by_id('kw')
            so.send_keys('无涯')
            self.driver.find_element_by_id('su').click()
            self.assertEqual(so.get_attribute('value'),'无涯')
            sleep(3)

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

执行调用文件名

```
test_operateFiles.py
```

内容：

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
import sys
import unittest
import os
import HTMLTestRunner

'''
如果是在python2中，一定要加如下代码，如果不加会出现中文enicode error的错误信息
import sys
reload（sys）
sys.setdefaultencoding('utf-8')
'''

'''文件调用方法'''
def OperateFiles():
    discover = unittest.TestLoader().discover(
    start_dir=os.path.dirname(__file__),
    pattern='test_*.py',
    top_level_dir=None)
    return discover

'''文件执行方法'''
def Run():
    # unittest.TextTestRunner(verbosity=2).run(OperateFiles())
    file = os.path.join(os.path.dirname(__file__),'report','testreport.html')
    HTMLTestRunner.HTMLTestRunner(
        stream=open('file','wb'),
        title='UI自动化测试',
        description='中台UI自动化测试详细信息').run(OperateFiles())

if __name__ == '__main__':
    Run()

```

### 10.测试代码覆盖率coverage

使用方法详细参考（可以写个py文件，驱动进行代码覆盖率的测试，不需要老是调用指令）

https://www.cnblogs.com/coderzh/archive/2009/12/01/pythoncoverage.html

https://blog.csdn.net/piapiada/article/details/50624372

# 第九章 Requests库接口测试

## 一.初试request-豆瓣网和拉勾网访问

注意⚠️：post请求里面data是传递基于from表单的数据，json的请求参数是基于json格式请求的字符串

![image-20191125215742795](/Users/apple/Library/Application Support/typora-user-images/image-20191125215742795.png)

```python
'''豆瓣网访问
写了反爬虫，暂时不考虑
'''
import requests
params = {'search_text':'沈强','cat':'1002'}
url = requests.get(url='https://movie.douban.com',params=params)
'''网络协议状态码'''
print(url.status_code)
'''请求正文，返回内容为text格式的字符串'''
print(url.text)
# '''先把test用content转化成二进制，然后编码解码成utf-8'''
# print(url.content.decode('utf-8'))
# '''请求地址'''
# print(url.url)
# '''请求地址的编码'''
# print(url.encoding)
# '''除非确定是json格式的字符串，不然不要使用json方法'''
# # print(url.json())
```

```python
'''
拉勾网爬取数据
Cookie:填写
因为拉勾网写了反爬虫，读出的数据为：
{"status":false,"msg":"您操作太频繁,请稍后再访问","clientIp":"221.224.144.84","state":2402}
'''

import requests
data = {'first':'true','pn':1,'kd':'自动化测试'}
headers = {
    'Accept':'application/json',
    'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
    'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36',
    'Cookie':'*'
   }
'''
verify=False：绕过ssl协议
timeout = 5：预防请求超时
'''
r =requests.post(url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false',data=data,headers=headers,verify=False,timeout = 5)
print(r.text)
```

## 二.访问公司后台

注意⚠️：在物联网的业务中，如果上报信息超时时间不确定，可以使用轮循的方法，每间隔一段时间查找一次，超出总时间就抛出异常

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

'''
注意输入的参数，进行序列化和反序列化
'''
import json
import requests

headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}

'''注意区分post方法里面表单数据使用data，json格式的字符串需要用json'''
data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

r = requests.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                  json=data,
                  headers=headers
                  )
'''公司后台返回的是字符串'''
# print(r.text,type(r.text))
'''
1。调用indent进行格式转换，转换成json格式
2。调用ensure_ascii进行编码转换，unicode编码的汉语转换成utf-8的汉语
'''
print(json.dumps(r.json(),indent=True,ensure_ascii=False))
```

## 三.Cookies的传递（根据公司回传）

```python
'''
注意区分：http协议和websocket协议的区别
http是建立一次链接，当然也可以通过ajax进行轮询，但是效率比较低，会有超时的风险
websocket是和服务器建立双向的持久性链接
'''
import json
import requests

def gitHeaders():
    headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}
    return headers

data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

'''登陆return cookies'''
def  urlTest():
    r = requests.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                      json=data,
                      headers=gitHeaders()
                      )
    return r.cookies

'''调用cookies'''
def getUrlTest():
    get = requests.get(url='http://lyfadmin.edu.laiyifen.com/guide/getBackGuideSetting.do',
                       cookies = urlTest())
    print(json.dumps(get.json(),indent=True,ensure_ascii=False))

getUrlTest()
```

## 四.动态参数获取和token获取

使用json方法，获取对应key的下标，去取对应参数的value，return 给目标函数调用

注意⚠️：这部分的知识怎么运用在取动态参数上。

例如：

```python
返回的数据类型格式为：
{
'start':0,
'msg':'',
'data':{
  'tocken':'1234568'
  ...
}
}

return r.json()['data']['token']
```

## 五.Requests对认证的处理（出现401或403报错）

详细参考我的博客园：https://www.cnblogs.com/shen-qiang/p/11936320.html

```python

'''
什么时候需要对认证做处理：
当请求返回状态码为401或403，且msg为：{"error": "Unauthorized access"}
'''   
import requests 
from requests.auth import HTTPBasicAuth 

r=requests.get( ‘http://localhost:5000/hotel/username/‘, 
auth=HTTPBasicAuth(‘wuya‘,‘admin‘)) 

print (r.text)
```

![image-20191126162423820](/Users/apple/Library/Application Support/typora-user-images/image-20191126162423820.png)

## 六.requests对session的处理

实例化requests.Session()对象，session建立后可以保持cookie的链接，不需要return cookie

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import json
import requests

def gitHeaders():
    headers = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html'}
    return headers

data={"username":"lyfadmin","password":"liuhaijun123456","type":1}

'''登陆return session'''
def  urlTest():
    '''实例化session对象'''
    sessionID = requests.Session()
    '''直接调用session'''
    sessionID.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                      json=data,
                      headers=gitHeaders()
                      )
    return sessionID

'''调用session'''
def getUrlTest():
    get = urlTest().get(url='http://lyfadmin.edu.laiyifen.com/guide/getBackGuideSetting.do')
    print(json.dumps(get.json(),indent=True,ensure_ascii=False))

getUrlTest()
```

## 七.Requests对文件的上传和下载

### 1.文件的上传

注意⚠️：上传文件的请求的key和value值需要用单引号阔起来。如果有双引号，需要对参数进行转译，处理起来很麻烦

![image-20191126193737085](/Users/apple/Library/Application Support/typora-user-images/image-20191126193737085.png)

```python
#!/use/bin/env python
#coding:utf-8
#Author:shenqiang

import  requests

'''传递的数据'''
data={
	"upload":"提交",
	"__channel":"renren",
	"privacyParams":'{"sourceControl": 99}',
	'hostid':'967004081',
	'requestToken':'-1124080368',
	'_rtk':'88c0e36a'}

'''上传文件的'''
files = {"file":
	        ("11.jpg", open("/Users/apple/Desktop/11.jpg", "rb"), "image/jpeg",{})}


'''hearders'''
headers={'Conteny-Type':'multipart/form-data',
         'Cookie':'wp_fold=0; jebe_key=2ebfe84a-ba39-4685-a7d4-2c2554a2c332%7Caa130ffbb5d8cc8d315a4ab7b5b427ae%7C1574763933779%7C1%7C1574763934663; jebecookies=bdca1d47-b697-4140-a2e0-ac30c4a5b558|||||; loginfrom=null; ver=7.0; WebOnLineNotice_972956233=1; XNESSESSIONID=abbe86d381c3; id=972956233; societyguester=0b0dfda34622b4fdc5f63d33bc8bbae53; t=0b0dfda34622b4fdc5f63d33bc8bbae53; xnsid=58c37e4b; ick=0a1287c1-023e-4868-bd07-bb96efea9185; ick_login=34b7eeb3-51ed-4d82-9c49-37d953b00269; __utma=151146938.1362702986.1574763700.1574763700.1574763700.1; __utmb=151146938.3.10.1574763700; __utmc=151146938; __utmz=151146938.1574763700.1.1.utmcsr=renren.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmt=1; _de=199FB1745CB4DC6D74D4674661EB8018; _r01_=1; anonymid=k3fpklmh-s0sajh; depovince=ZGQT',
         'User-Aaent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'}

'''文件上传'''
r=requests.post(
	url='http://head2.upload.renren.com/head2/UploadFacade.do?pagetype=customheadupload&hostid=972956233&uploadid=1574764014376',
	data=data,
	headers=headers,
	files=files)

'''上传状态和文本内容'''
print(r.status_code)
print(r.text)

```

### 2.文件的下载(重要！)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

'''
注意：定义类的时候，内部方法之间的互调
步骤：
1.按照流的方式进行下载
2.存储在某个文件中
'''
import requests
import shutil
import time

class DownLoadFile():

    def readyDatas(self):
        '''
        准备数据：固定参数
        :param datas 接口参数
        :param downLoadPath 下载文件地址
        '''
        times = time.strftime("%Y-%m_%d %H_%M_%S", time.localtime(time.time()))

        self.datas = {"username":"lyfadmin","password":"liuhaijun123456","type":1}
        self.downLoadPath = '/Users/apple/Documents/TestCode/tryApiTest/requestsPractice/Files{0}.xlsx'.format(times)

        return self.datas,self.downLoadPath

    def getHearders(self):
        '''
        :return: Hearders 接口报文的头信息
        '''
        self.Hearders = {'Content-Type':'application/json;charset=UTF-8','Referer':'http://lyfadmin.edu.laiyifen.com/plugins/platform-include/views/login.html',
               'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'}
        return  self.Hearders

    def setSession(self):
        '''
        :return: SessionId 返回网址的Session信息
        '''
        self.readyDatas()
        self.getHearders()
        self.sessionId = requests.Session()
        self.sessionId.post(url='http://lyfadmin.edu.laiyifen.com/ouser-web/mobileLogin/login.do',
                                  json = self.datas,
                                  headers = self.Hearders)
        return self.sessionId

    def downFiles(self):
        '''
        下载文件
        '''
        self.setSession()
        loginStatus = self.sessionId.get('http://lyfadmin.edu.laiyifen.com/promotion-static/template/coupon.xlsx',
                                         headers = self.Hearders,
                                         stream = True )
        if loginStatus.status_code == 200:
            with open(self.downLoadPath,'wb') as files:
                '''Function1'''
                # for chunk in loginStatus.iter_content(chunk_size=1024):
                #     files.write(chunk)
                '''function2'''
                loginStatus.raw.decode_content = True
                shutil.copyfileobj(loginStatus.raw, files)
            print('file download succeed')
        else:
            print('file download failed')


if __name__ == '__main__':
    DownLoadFile = DownLoadFile()
    DownLoadFile.downFiles()
```

# 第十章数据驱动

## 一.execl数据驱动

### 1.xlutils简要说明

导包：pip3 install xlutils

注意⚠️：xlutils在介些Execl文件的时候，只识别.xls后缀的文件，如果是.xlsx后缀的文件被解析，.xlsx后缀的文件会被破坏

### 2.接口自动化中对execl简单的读取

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

'''xlrd写入文件，同时清空原文件,一般这种方法只用来读'''
import xlrd
import os

'''拿到文件的路径'''
def base_path(filename = None):
    return os.path.join(os.path.dirname(__file__),filename)

'''读取文件内容'''
work = xlrd.open_workbook(base_path('execlTestFile.xls'))

'''以下标或者sheet名取对应的哪页'''
sheet = work.sheet_by_index(0)
# sheet = work.sheet_by_name()

'''查看文件有多少行'''
print(sheet.nrows)

'''获取单元格内容,第3行，第3列'''
print(sheet.cell_value(2,2))
```

### 3.改写execl文件的内容

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import xlrd
import os
from xlutils.copy import copy

'''拿到文件的路径'''
def base_path(filename = None):
    return os.path.join(os.path.dirname(__file__),filename)

'''打开文件'''
work = xlrd.open_workbook(base_path('execlTestFile.xls'))
'''把文件内存存在一个变量里'''
file_content = copy(work)
'''拿到文件需要改写的sheet页'''
file = file_content.get_sheet(0)
# print(file_content)
'''
定位文件位置写入内容
行和列以从0开始数下标
'''
file.write(2,2,'沈强')
'''保存文件，并且重新命名'''
file_content.save(base_path('execlTestFile.xls'))
```

### 4.configparser配置文件的读取（服务和数据库连接）

配置文件名

config.ini

文件内容：

```ini
[linux]
ip:10.0.13.26
port:22
username:root
password:W2ynE6b58wheeFho

[mysql]
ip:10.0.13.26
port:22
username:root
password:W2ynE6b58wheeFho
```

文件名

```python
tryConfigparser.py
```

文件内容

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import os
import configparser

'''拿到文件的路径'''

def base_path(filename=None):
    return os.path.join(os.path.dirname(__file__), filename)

'''函数的默认参数处理'''
def getConfigparser(Linux='linux'):
    '''实例化对象'''
    config = configparser.ConfigParser()
    '''读取文件内容'''
    config.read(base_path('config.ini'))
    ip = config.get(Linux, 'ip')
    port = config.get(Linux, 'port')
    username = config.get(Linux, 'username')
    password = config.get(Linux, 'password')
    return [ip, port, username, password]

print(getConfigparser(),type(getConfigparser()))

# '''遍历文件内容'''
# for i in range(len(getConfigparser())):
#     print(getConfigparser()[i])

```

### 5.mysql常用的一些操作指令

```python
启动MySQL服务
mysql.server start

停止MySQL服务
mysql.server stop

重启MySQL服务
mysql.server restart

进入MySQL数据库
mysql -u root -p
Password: 密文传输（shen6409175）
  
'''查看数据库'''
show databases;
'''选中数据库'''
use students;
'''查看表'''
show tables;
'''创建表'''
create table student(
   id int primary key,
   name varchar(50),
   age varchar(10),
   address varchar(100)
   );
'''查看表结构'''
desc student;
'''查看表设计'''
show create table student;
```

## 二.MySQL数据驱动

### 1.数据库查询

```python
#!/user/bin/env python
# coding:utf-8
# Author:shenqiang
import pymysql

def connectMysql():
    try:
        '''链接数据库'''
        connect = pymysql.connect(
            host='127.0.0.1',
            user='root',
            password='shen6409175',
            db='students'
        )
    except Exception as  e:
        return e.args
    else:
        '''创建游标'''
        cur = connect.cursor()
        '''SQL语句分离'''
        # sql = 'select * from student where id = %s'
        # params = (2,)
        # '''查重'''
        # cur.execute(sql,params)
        # '''单条数据的查询'''
        # data = cur.fetchone()
        # return datas
        sql = 'select * from student'
        '''查重'''
        cur.execute(sql)
        '''多条数据查询'''
        datas = cur.fetchall()
        '''方法一，遍历'''
        # for data in datas:
        #     print(data)
        '''方法二，列表推倒式'''
        db = [data for data in datas]
        return db

    finally:
        # 关闭游标和链接
        cur.close()
        connect.close()

print(connectMysql())
```

### 2.数据库插入数据

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import pymysql

def connectMysql():
    try:
        '''链接数据库'''
        connect = pymysql.connect(
            host='127.0.0.1',
            user='root',
            password='shen6409175',
            db='students'
        )
    except Exception as  e:
        return e.args
    else:
        '''创建游标'''
        cur = connect.cursor()
        '''导入数据'''
        # 单条语句的插入
        # sql = 'insert into student values(%s,%s,%s,%s);'
        # params = (6,'沈～','24','南京')
        '''批量插入数据'''
        sql = 'insert into student values(%s,%s,%s,%s);'
        params = [
            (7, '沈～', '24', '南京'),
            (8, '沈～', '24', '南京')
            ]
        cur.executemany(sql,params)
        '''insert后必须要commit()'''
        connect.commit()
    finally:
        # 关闭游标和链接
        cur.close()
        connect.close()

connectMysql()
```

### 3.数据库删除数据

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import pymysql

def connectMysqlDelect():
    try:
        '''连接数据库'''
        connectMysqlDelect = pymysql.Connect(
            host = '127.0.0.1',
            user = 'root',
            password = 'shen6409175',
            db = 'students',
        )
    except Exception as  e:
        print(e.args)
    else:
        '''创建游标'''
        cur = connectMysqlDelect.cursor()
        '''执行sql'''
        mysql = 'delete from student order by id desc limit 1'
        cur.execute(mysql)
        '''提交事务'''
        connectMysqlDelect.commit()
        print('success')
    finally:
        '''关闭游标和数据库'''
        cur.close()
        connectMysqlDelect.close()

connectMysqlDelect()
```

### 4.一个完整的Mysql数据驱动方式

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import pymysql

class MysqlTry:
    '''链接数据库'''
    def connectMysql(self):
        '''尝试链接数据库'''
        try:
            connect =pymysql.connect(
                host = '127.0.0.1',
                user='root',
                password='shen6409175',
                db='students'
            )
        except Exception as e:
            print(e.args)
        return connect

    def selectMysql(self,sql,params):
        '''创建游标'''
        cur = self.connectMysql().cursor()
        '''查重'''
        cur.execute(sql,params)
        '''查询'''
        result = cur.fetchall()
        '''删除游标'''
        cur.close()
        return result

def checkValid(username,age):
    opera = MysqlTry()
    sql = "select * from student where name = %s and age = %s"
    params=(username,age)
    return opera.selectMysql(sql=sql,params=params)

def checkinfo():
    username = input('请输入用户名 \n')
    age = input('请输入用户年龄 \n')
    result = checkValid(username,age)
    if result:
        '''关闭数据库'''
        MysqlTry().connectMysql().close()
        print('该用户在数据库中，测试通过！')
    else:
        print('该用户不在数据库中，存在bug！')

if __name__ == '__main__':
    checkinfo()
```

## 三.CSV数据驱动

注意⚠️：CSV文件的生成，只有通过文件软件的另存为csv格式才可生成没有异常的文件，千万不可以直接修改文件后缀名。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import csv

'''读取csv文件的方法'''
def ReadCsvlist():
    '''方法一:列表方式取数据'''
    '''通过列表提取csv文件'''
    with open('csvTestFile.csv') as file:
        '''reader是csv的迭代器'''
        reader = csv.reader(file)
        '''跳过首行'''
        next(reader)
        '''列表推倒式'''
        db =  [item for item in reader]
        return db

print(ReadCsvlist(),type(ReadCsvlist()))

#     '''方法二：字典的格式输出csv文档内容'''
#     with open('csvTestFile.csv',encoding='utf-8') as file:
#         reader = csv.DictReader(file)
#         for item in reader:
#             print(dict(item))
#
# ReadCsvlist()
```

## 四.爬取拉勾网实例

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

import  csv
import  requests

def getHeaders():
	headers={
		'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
		'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
		'Cookie':'_ga=GA1.2.1237290736.1534169036; user_trace_token=20180813220356-b7e42516-9f01-11e8-bb78-525400f775ce; LGUID=20180813220356-b7e428ad-9f01-11e8-bb78-525400f775ce; index_location_city=%E5%85%A8%E5%9B%BD; _gid=GA1.2.675811712.1540794503; JSESSIONID=ABAAABAAAGFABEF93F47251563A52306423D37E945D2C54; _gat=1; LGSID=20181029213144-fa3c8e13-db7e-11e8-b51c-525400f775ce; PRE_UTM=; PRE_HOST=www.bing.com; PRE_SITE=https%3A%2F%2Fwww.bing.com%2F; PRE_LAND=https%3A%2F%2Fwww.lagou.com%2F; Hm_lvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1539529521,1539785285,1540794503,1540819902; SEARCH_ID=ae3ae41a58d94802a68e848d36c30711; Hm_lpvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1540819909; LGRID=20181029213151-fe7324dc-db7e-11e8-b51c-525400f775ce',
'Referer':'https://www.lagou.com/jobs/list_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88?labelWords=sug&fromSearch=true&suginput=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95'}
	return headers

def laGou(url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false',page=2):
	positions = []
	r = requests.post(
		url=url,
		headers=getHeaders(),
		data={'first': False, 'pn': page, 'kd': '自动化测试工程师'})
	for i in range(15):
		city = r.json()['content']['positionResult']['result'][i]['city']
		education = r.json()['content']['positionResult']['result'][i]['education']
		workYear = r.json()['content']['positionResult']['result'][i]['workYear']
		positionAdvantage = r.json()['content']['positionResult']['result'][i]['positionAdvantage']
		salary = r.json()['content']['positionResult']['result'][i]['salary']
		companyFullName = r.json()['content']['positionResult']['result'][i]['companyFullName']
		positionLables = r.json()['content']['positionResult']['result'][i]['positionLables']
		position = {
			'公司名称': companyFullName,
			'城市': city,
			'学历': education,
			'工作年限': workYear,
			'薪资': salary,
			'工作标签': positionLables,
			'福利': positionAdvantage
		}
		positions.append(position)
	for item in positions:
		print(item)

if __name__ == '__main__':
	for item in range(1, 31):
		laGou(page=item)
```

## 五.DDT测试驱动

注意⚠️：有相同执行步骤的测试用例可以使用ddt

### 1.基本介绍

详细使用方法参考我的博客圆：https://www.cnblogs.com/shen-qiang/p/11954061.html

```python
注意⚠️：以下代码不可执行
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang
import  csv
import  requests
import  ddt
import  unittest

url='https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false'

def getHeaders():
   headers={
      'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
      'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
      'Cookie':'_ga=GA1.2.1237290736.1534169036; user_trace_token=20180813220356-b7e42516-9f01-11e8-bb78-525400f775ce; LGUID=20180813220356-b7e428ad-9f01-11e8-bb78-525400f775ce; index_location_city=%E5%85%A8%E5%9B%BD; _gid=GA1.2.675811712.1540794503; JSESSIONID=ABAAABAAAGFABEF93F47251563A52306423D37E945D2C54; _gat=1; LGSID=20181029213144-fa3c8e13-db7e-11e8-b51c-525400f775ce; PRE_UTM=; PRE_HOST=www.bing.com; PRE_SITE=https%3A%2F%2Fwww.bing.com%2F; PRE_LAND=https%3A%2F%2Fwww.lagou.com%2F; Hm_lvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1539529521,1539785285,1540794503,1540819902; SEARCH_ID=ae3ae41a58d94802a68e848d36c30711; Hm_lpvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1540819909; LGRID=20181029213151-fe7324dc-db7e-11e8-b51c-525400f775ce',   'Referer':'https://www.lagou.com/jobs/list_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88?labelWords=sug&fromSearch=true&suginput=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95'}
   return headers

def f():
   list1=[]
   t=[i for i in range(1,31)]
   list1.append(t)
   return list1

@ddt.ddt
class LaGou(unittest.TestCase):
   @ddt.data((1,),(2,),(3,))
   @ddt.unpack
   def test_laGou(self,page):
      positions = []
      r = requests.post(
         url=url,
         headers=getHeaders(),
         data={'first': False, 'pn': page, 'kd': '自动化测试工程师'})
      self.assertEqual(r.json()['success'],True)
      print(r.json()['content']['positionResult']['result'][0]['city'])

if __name__ == '__main__':
   unittest.main(verbosity=2)
```

### 2.DDT的简单应用

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

from ddt import data,unpack,ddt
import unittest

@ddt
class MyDdtTest(unittest.TestCase):

    @data((1,1),(2,2),(3,3))
    @unpack
    def test_ddt(self,value1,value2):
        print('实际参数{0},预期参数{1}'.format(value1,value2))
        print(self.assertEqual(value1,value2))

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

## 六.对XML文件的读取

XML文件格式

![image-20191129212515675](/Users/apple/Library/Application Support/typora-user-images/image-20191129212515675.png)

XML文件读取方法

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
import xml.dom.minidom

# def dirverXml(value=None):
#     '''取得单节点的数据'''
#     xmlFile = xml.dom.minidom.parse('data.xml')
#     db = xmlFile.documentElement
#     itemList = db.getElementsByTagName(value)
#     item = itemList[0]
#     return item.firstChild.data
#
# print(dirverXml('admin'))

def dirverXmlName(parent=None,child = None):
    '''取得单节点的数据内容'''
    xmlFile = xml.dom.minidom.parse('data.xml')
    db = xmlFile.documentElement
    itemList = db.getElementsByTagName(parent)
    item = itemList[0]
    return item.getAttribute(child)

print(dirverXmlName('WuYA','nick'))
```

## 七.测试执行的log读取

```python
#!/user/bin/env python
#coding:utf-8
#Author:shenqiang

import  logging
from selenium import  webdriver
import  unittest

def log(log_content):
    # 定义文件
    logFile = logging.FileHandler('log.md', 'a',encoding='utf-8')
    # log格式
    fmt = logging.Formatter(fmt='%(asctime)s-%(name)s-%(levelname)s-%(module)s:%(message)s')
    logFile.setFormatter(fmt)

    # 定义日志
    logger1 = logging.Logger('', level=logging.DEBUG)
    logger1.addHandler(logFile)
    logger1.info(log_content)

class Ui(unittest.TestCase):
    def setUp(self):
        self.driver=webdriver.Chrome()
        log('初始化浏览器')

    def test_001(self):
        log('开始测试')
        pass

    def tearDown(self):
        log('测试结束')
        self.driver.quit()

if __name__ == '__main__':
    unittest.main(verbosity=2)
```

# 第十一章 接口测试框架设计应用与案例实战

## 一.如何进行数据分离(⚠️)

自动化测试纬度：1.功能上的UI自动化测试 、2.接口上的API自动化测试 、3.单元层的自动化测试

自动化测试的难点：如何进行数据分离

分离的数据有哪些:   url 请求头 请求参数  请求方法

分离的数据处理方法：

- 1.放入数据库，需要执行sql（需要大量的sql，而且服务器有问题数据会有影响）
- 2.放入文件中（Excel、CSV、config、XML），最好通过execl，需要往文件写入测试结果
  - 注意⚠️面临的问题：
    - 对于请求参数很多的接口，Excel文件修改接口请求信息比较麻烦（通过读取json文件处理）
    - 脚本维护成本
    - 接口自动化测试执行效率
    - json文件中True、False和Null的处理需改改成'true'、'false'、''
- 3.动态参数的处理
  - 形式参数参数化

## 二.API自动化构建测试框架的维度

- 目录优化
- 数据分离
- 获取json文件内容
- 关联excel与json的请求参数
- 对POST请求的二次封装
- 编写测试用例
- 增加断言
- 重构代码
- 当请求参数是动态参数的处理
- 参数关联业务处理
- 关联参数写入文件
- 检测headers函数
- 测试结果写入文件
- 统计测试成功率
- 新增发送邮件功能
- 针对平台加密数据处理

## 三.自动化测试框架设计案例（首页测试搜索命中率）

其中包含：登录，session传递，同义词、近义词、关联商品、复杂商品搜索、热词搜索，历史搜索。

## 四.以拉勾网为例子，进行API自动化测试例子

详细代码参考：https://github.com/ShenQiangTestLovers/TestCode/tree/master/lagouAPITest

## 五.针对平台加密数据处理

接口自动化需求和问题：

“1.对请求参数按照key-value的格式，进行参数名的ascill码排序

- 请求参数不确定
- 怎么排序

2.在第一步的结果字符串尾部拼接密钥

- name=shenqiang&age=28&address=nanjing&sex=boy+密钥

3.排序后，对请求的参数进行MD5加密“

- hashlib



解决方法（思路）

1.请求参数不确定--->动态参数 *args，**kwargs

2.怎么排序--->			sorted()

3.请求地址尾部密钥拼接可以用urllib的parse

4.hashlib加密

```python
from urllib import parse
import hashlib

def dataSign(secure='shenqiang',*args,**kwargs):
    '''对字典的key进行排序'''
    dict2 = dict(sorted(kwargs.items(),key=lambda item:item[0]))
    '''对url进行拼接'''
    str1 = parse.urlencode(dict2)+secure
    '''进行MD5加密'''
    # 实例化MD5
    md = hashlib.md5()
    md.update(str1.encode('utf-8'))
    return md.hexdigest()

'''data2参数不确定'''
data2 = {"a":"2","c":"1","b":"3"}

print(dataSign(**data2))
```

## 六.编写自动化的原理图

![image-20191215221238282](/Users/apple/Library/Application Support/typora-user-images/image-20191215221238282.png)

## 七.工厂模式在自动化测试过程中的应用

### 为什么选择工厂设计模式

在UI的自动化测试中,Selenium框架与 Appium框架存在共同的类，特别是Appium 框架中操作元素属性的类MobileBy类继承了 Selenium框架的By类,那么基于这样的一个事实，使用工厂设计模式的思想，把两个框 架整合到一起编写一个基于UI的测试框架，这样就可以使用一套测试框架同时测试 WEB和APP。

### 工厂设计模式的代码实例

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.expected_conditions import NoSuchElementException
from selenium.webdriver.support.wait import WebDriverWait
from appium import webdriver
from appium.webdriver.common.mobileby import MobileBy

class Factory(object):
    def __init__(self,driver):
        self.driver=driver

    def createDriver(self,driver):
        '''工厂方法'''
        if driver=='web':
            return WebUi(self.driver)
        elif driver=='app':
            return AppUi(self.driver)

class WebDriver():
    def __init__(self,driver):
        self.driver=driver
    def findElement(self,*loc):
        try:
            return WebDriverWait(self.driver,20).until(
                lambda x:x.find_element(*loc))
        except NoSuchElementException as e:
            print(e.args[0])

    def findElements(self,*loc):
        try:
            return WebDriverWait(self.driver,20).until(
                lambda x:x.find_elements(*loc))
        except NoSuchElementException as e:
            print(e.args[0])

class WebUi(WebDriver):
    def __str__(self):
        return 'WebUi'

class AppUi(WebDriver):
    def __str__(self):
        return 'AppUi'

```

# 第十二章 持续集成(CI)

## 一.Jenkins安装

详情参考：https://blog.csdn.net/liqing0013/article/details/83930419

## 二.插件的安装

步骤：1.点击系统管理

​			2.点击管理插件：http://localhost:8080/jenkins/pluginManager/

​			3.必须安装的插件

​					Ant									-->jmerter测试工具使用

​					Checkstyle						--->检测代码

​					Cobertura						----->代码覆盖率

​					Email Extension				---->发送邮件	

​					Git										----->仓库托管

​					HTML Publisher				------>生成html报告

​					Violations plugin				------>输出违规报告

​					xUnit plugin						----->单元测试报告

​					svn										------>可用可以不用

​					Performance						----->性能测试报告插件



## 三.邮件的配置

1.点击系统管理

2.点击系用设置:http://localhost:8080/jenkins/configure

3.邮件配置

- 系统管理员邮件地址必须填写
- 邮件通知
  - java：
    - maven自动打成.war
    - 把.war放到tomcat的webapps目录下
    - 重新启动tomcat服务

![image-20191206153810979](/Users/apple/Library/Application Support/typora-user-images/image-20191206153810979.png)

![image-20191206154017674](/Users/apple/Library/Application Support/typora-user-images/image-20191206154017674.png)

## 四.Global Tool配置

Global Tool Configuration配置：
1、点击系统管理
2、点击	Global Tool Configuration
3、必须配置：
   jdk
   git
   ant
   maven
   注意事项:指定jdk,git,ant的安装路径,git特别注意，要制定到具体的git.exe路径



## 五.git详细应用

1、git安装好之后，建议按照git的管理客户端工具:TortoiseGit
2、密钥的生成:
   ssh-keygen -t rsa -C "wuya@outlook.com"  gitlab  
   git config --global user.name "wuya"
   git config --global user.email "wuya@outlook.com"

   查看是否配置好：
   git config --list 

   git init-->初始化
   git add .-->提交文件
   git commit -m "备注信息"
   git push--->把本地的代码提交到服务器 (github)
   git pull-->把服务器的代码与本地代码同步

   两点：
   1、注册github账号，把本地的代码提交到github
   2、配置你的ide开发工具  提交代码



## 六.jmeter的jenkins的整合

![image-20191206203331683](/Users/apple/Library/Application Support/typora-user-images/image-20191206203331683.png)

![image-20191206203532954](/Users/apple/Library/Application Support/typora-user-images/image-20191206203532954.png)

![image-20191207161422417](/Users/apple/Library/Application Support/typora-user-images/image-20191207161422417.png)

![image-20191207161454125](/Users/apple/Library/Application Support/typora-user-images/image-20191207161454125.png)

## 七.Allure环境配置

1. 安装allure的插件
2. 配置安装allure步骤：
  A.系统管理
  B.Global Tool Configuration
  C.找到Allure Commandline安装，点击后,进行安装,建议选择2.4.1版本
  D.点击保存
3.配置allure的保存
  A.系统管理
  B.系统设置
  C.最后找到Allure Report后，进行配置：
    key:WORKSPACE(不可以更改)
	value:D:/git/Python/Four/report
  D.点击保存
4.执行后，生成allure的测试报告:
  A.打开job的配置
  B.增加构建后操作步骤中的Allure Report
  C.填写report
5.安装如下python第三方的库：
   pip  install pytest 
   pip  install pytest-allure-adaptor
6. 安装第五点的第三方的库成功之后，在构建步骤中填写如下的信息：
	cd D:/git/github/irainui/testCase
	d:
	python -m pytest  --alluredir ${WORKSPACE}/report
7.执行后，生成allure的测试报告

官方地址：https://docs.qameta.io/allure/

安全策略：
1.系统管理
2.Configure Global Security

测试用例的执行：
1、编写了UI的自动化
2、接口的测试用例
需求：
先执行接口后自动执行UI的测试用例
具体：先UI后Jmetet4.0

## 八.定时任务（crontabs）

1.配置失败增加邮件通知

2.定时任务的讲解

3.多个工程的进行

4.安全策略的配置

5.接口的持续监控

### 定时任务：

安装命令：

crontab -l

yum install crontabs 

命令格式如下：

![image-20191207214820971](/Users/apple/Library/Application Support/typora-user-images/image-20191207214820971.png)

![image-20191207214916806](/Users/apple/Library/Application Support/typora-user-images/image-20191207214916806.png)

### 构建失败邮件通知

![image-20191207215700750](/Users/apple/Library/Application Support/typora-user-images/image-20191207215700750.png)

### Jenkins中工程上下联动执行

执行顺序：

1.接口测试用例执行

2.UI自动化测试用例

3.手工执行：没覆盖到的场景+新的功能点+验证失败的自动化测试用例

注意⚠️：通过配置构建触发器，在API自动化测试后，进行UI自动化测试

![image-20191207221742053](/Users/apple/Library/Application Support/typora-user-images/image-20191207221742053.png)

### 实现本地与CI服务器的远程构建

1.本地完善编写测试脚本

2.把编写的测试脚本调试通过后，提交到git

3.CI构建的过程是怎么样的？

- 把最新的代码从Git服务器获取到更新到CI平台（一般CI构建在云服务或者公司自己的服务器上）
- 在CI的终端执行测试脚本

注意⚠️：git上有两个密钥，一个提供给本地用于提交源码，另一个提供给jenins服务用于CI的远程构建

### Jenkins可能遇到的问题

#### 1.新的jenkins已经取消了默认的账户，导致安装插件成功后，点击继续使用，或出现空白页面，或者推出后，登录账号后不知道以哪个登录，遇到该问题，解决方案如下：



Linux终端：

1.停止tomcat的运行

2.删除.jenkins的文件夹（root的根目录），删除命令为：

cd

rm -rf  .jenkins/

3.在tomcat的webapps目录下，删除jenkins的目录

4.重新启动tomcat

5.安装插件

6.切换创建用户，该创建的用户就是管理员的账户

7.创建的账户登录jenkins就可以了



#### 2.IDE正常执行，但是CI执行的时候，提示XX模块不存在

把缺失的模块加到path中，代码：

```python
import sys
page_path = os.path.join(os.path.dirname(os.path.dirname(__file__)),'page')
sys.path.append(page_path)
```

#### 3.IDE中提示XX模块不存在

方法同2

#### 4.Allure生成不了测试报告

Pytest高版本导致的，可以安装pytest==4.0.2版本

## 九.GitLab环境搭建

参考：https://www.jianshu.com/p/fcba3326c125

gitlab默认的是80端口，需要开放端口

# 第十三章 Mock测试

## 一.moco的简单应用

moco地址：https://github.com/dreamhead/moco
api文档地址：
https://github.com/dreamhead/moco/blob/master/moco-doc/apis.md
启动命令：
java -jar moco-runner-1.0.0-standalone.jar http -p 12306 -c foo.json

moco只关注服务器的配置，也就是客户端与服务端，或者更加具体的说就是请求和响应。

实例：

![image-20191208181029605](/Users/apple/Library/Application Support/typora-user-images/image-20191208181029605.png)

![image-20191208181058263](/Users/apple/Library/Application Support/typora-user-images/image-20191208181058263.png)

![image-20191208181115584](/Users/apple/Library/Application Support/typora-user-images/image-20191208181115584.png)

![image-20191208182402751](/Users/apple/Library/Application Support/typora-user-images/image-20191208182402751.png)

## 二.mock的介绍与详解

mock在python3.3之前是第三方库，在python3.3版本之后是标准库，只需要导入就可以使用。

Python3.3版本之前引入方式是

import mock

python3.3版本之后的引入方式是

from unittest import mock

Mock的意义：Mock能够让我们模拟那些在单元测试中不可用或太笨重的资源

Mock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象，以达到摸你对象的行为。Mock它可以替换Python对象。



### 1.使用现实情况：

1.环境由于客观原因导致无法搭建

2.搭建服务器需要大量的工作才可以



案例：

1.测试一个网站

不存在的网站www.wuya.com
200
404
500
400
401
403

模拟进行200，404，

2.测试C盘

### 2.Mock和MagicMock

在单元测试进行的同时，就离不开mock模块的存在，初次接触这个概念的时候会有这样的疑问：把要测的东西都模拟掉了还测试什么呢？
　　但在，实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：
•接口的依赖
•外部接口调用
•测试环境非常复杂
单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的.使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。

![image-20191208230358610](/Users/apple/Library/Application Support/typora-user-images/image-20191208230358610.png)

因为在为代码进行单元测试的同时，会发现该模块依赖于其他的模块，例如数据库，网络，或者第三方模块的存在，而我们对一个模块进行单元测试的目的，是测试当前模块正常工作，这样就要避开对其他模块的依赖，而mock主要作用便在于，专注于待测试的代码。而在但与测试中，如何灵活的使用mock模块是核心所在。下面便以mock为核心，结合最近所写的代码，阐述mock模块的使用

### 3. mock模块的使用

在mock模块中，两个常用的类型为Mock，MagicMock，两个类的关系是MagicMock继承自Mock，最重要的两个属性是return_value, side_effect。

```python
>>> from mock import Mock
>>> fake_obj = Mock()
>>>fake_obj.return_value = 'This is a mock object'
>>> fake_obj()
'This is a mock object'
```

我们通过Mock()可以创建一个mock对象，通过renturn_value 指定它的返回值。即当下文出现fake_obj()会返回其return_value所指定的值。
也可以通过side_effect指定它的副作用，这个副作用就是当你调用这个mock对象是会调用的函数,也可以选择抛出一个异常，来对程序的错误状态进行测试。

```python
>>>def b():
...    print 'This is b'
...
>>>fake_obj.side_effect = b
>>>fake_obj()
This is b
>>>fake_obj.side_effect = KeyError('This is b')
>>>fake_obj()
...
KeyError: 'This is b'

```

如果要模拟一个对象而不是函数，你可以直接在mock对象上添加属性和方法，并且每一个添加的属性都是一个mock对象【注意，这种方式很有用】，也就是说可以对这些属性进行配置,并且可以一直递归的定义下去。

```python
>>>fake_obj.fake_a.return_value = 'This is fake_obj.fake_a'
>>>fake_obj.fake_a()
'This is fake_obj.fake_a'

```

上述代码片段中fake_obj是一个mock对象，而fake_obj.fake_a的这种形式使得fake_a变成了fake_obj的一个属性，作用是在fake_obj.fake_a()调用时会返回其return_value。
另外也可以通过为side_effect指定一个列表，这样在每次调用时会依次返回，如下：

```python
>>> fake_obj = Mock(side_effect = [1, 2, 3])
>>>fake_obj()
1
>>>fake_obj()
2
>>>fake_obj()
3
```

#### 3.1 函数的如何mock

在rbd_api.py文件中如下内容：

```python
import DAO_PoolMgr

def checkpoolstat(pool_name)
  ret， poolstat = DAO_PoolMgr.DAO_query_ispoolok(pool_name)
if ret != MGR_COMMON.MONGO_SUCCESS:
    return ret
if poolstat is False:
    return MGR_COMMON.POOL_STAT_ERROR
return MGR_COMMON.SUCCESS

```

要为这个函数撰写单元测试，因为其有数据库的操作，因而就需要mock 出DAO_query_ispoolok操作。
因此，我们在test_rbd_api.py文件中可以这么写：因为DAO_query_ispoolok是类DAO_PoolMgr的操作，因此可以这么写

```python
#!/usr/bin/python
import DAO_PoolMgr
import unittest
import rbd_api as rbdAPI

class TestAuxiliaryFunction(unittest.TestCase):
	def setUp(self):
		self.pool_name = "aaa"
	
	def tearDown(self):
		self.pool_name = None
	@mock.patch.object(DAO_PoolMgr, "DAO_query_ispoolok")
	def test_checkpoolstat(self, mock_DAO_query_ispoolok):
		mock_DAO_query_ispoolok.return_value = (MGR_COMMON.POOL_STAT_ERROR, None)
		self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)

		mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, False)
		self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)
		
		mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, True)
		self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.SUCCESS)

```

测试用例上的装饰器含义如下：
@mock.pathc.object(类名，“类中函数名”)，而如果想要忽略某个测试用例，则可以通过装饰器@unittest.skip(“原因”)
而对于另外一种情形则是在另外一个函数中调用了checkpoolstat函数。
如下rbd_api.py：

```python
def checkpoolstat():
    ……

class Disk(Resource):
    def  __init__(self):
        ……
    def delete(self, pool, img):
        ret = rbd_api.checkpoolstat()
        ……
```

这样，我们在为delete函数撰写单元测试时，也可以在test_rbd_api.py中使用如下的方式：

```python
import rbd_api

class TestDisk(unittest.TestCase):
    def setup():
        …
      def teardown():
			  …
      @mock.patch(“rbd_api.checkpoolstat”, Mock(return_value = True))
      def test_delete():
         # rbd_api.checkpoolstat 已经成为一个mock对象了，调用时返回True
		    …
```

此时的装饰器应该为

```python
@mock.patch(“模块名.函数名”)
```

#### 3.2 链式函数抛出异常

在rbd_api.py文件中，有一行代码如下：

```python
rbdServ.OpRBD = MagicMock()
rbdServ.OpRBD(pool).side_effect = rados.Error(“Error: error connecting to the cluster: error code 24”)

```

#### 3.3 全局函数如何mock

例如在文件rbd_api.py中有全局函数checkpoolstat(pool)，它是一个全局函数，这样在进行单元测试的过程中，我们可能需要mock该函数。该函数的具体代码如下：

因此，我们在test_rbd_api.py文件中为该函数撰写单元测试，可以这么做。
在文件开始处导入该rbd_api模块。

```python
import rbd_api as rbdAPI
def test_patchInvalid_Parameter(self):
	……
	rbdAPI.checkpoolstat.return_value = MGR_COMMON.POOL_STAT_ERROR
	即可。
```

#### 3.4 链式调用正常

在rbd_api文件中有如下代码行

```python
ret = OpRBD(pool).flatten(img)
```

在第一个函数未出现异常，在flatten函数中返回值可以在test_rbd_api.py文件中如下写代码：

```python
rbdServ.OpRBD(pool).snap_rollback = MagicMock(return_value = RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY)
```

#### 3.5 with子句mock

```python
#!/usr/bin/python
import rados
class OpRBD:
	def __init__(self):
		...
	
	def __del__(self):
		...
	
	def resize(self, img, size):
		try:
			with rbd.Image(self.ioctx, img) as image:
				if image.size() < size:
					image.resize(size)
				else:
					return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL
		except rbd.ImageNotFound as exce1
		  print(exce1)
		  return RBD_COMMON.CODE_IMAGE_NOT_FOUND

```

由于是在with子句中要进行mock，在此简单的对with的知识点进行说明：
要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。
下面是一组与上下文管理器和with 语句有关的概念。

- 上下文管理协议（Context Management Protocol）：包含方法 enter() 和 exit()，支持
  该协议的对象要实现这两个方法。
- 上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了 enter() 和 exit() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，
  负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。
- 运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 enter() 和__exit__() 方法实现，enter() 方法在语句体执行之前进入运行时上下文，exit() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。
- 上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。
- 语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 enter() 方法，执行完语句体之后会执行 exit() 方法。
  出现异常时，如果 exit(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理。因此，在对with子句进行mock时，要具有两个函数，exit, enter，并且如果在with语句体重抛出异常并被with之外的代码进行捕获异常，要使得__exit__返回False，因此可以撰写测试代码如下

```python
    #!/usr/bin/python
    import rados
    class OpRBD:
     def __init__(self):
        ...
    	def __del__(self):
    		...
    	
        	def resize(self, img, size):
        		try:
        			with rbd.Image(self.ioctx, img) as image:
        				if image.size() < size:
        					image.resize(size)
        				else:
        					return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL
        		except rbd.ImageNotFound as exce1
        		  print(exce1)
        		  return RBD_COMMON.CODE_IMAGE_NOT_FOUND
        class TestOpRBD(unittest.TestCase):
        	def setUp(self):
        		...
        	def tearDown(self):
        		...
        	def test_resize(self):
        		fake_image = Mock()
        		fake_image.__enter__ = Mock(return_value = fake_image)
        		fake_image.__exit__ = Mock(return_value = True)
        		rbd.Image = Mock(return_value = fake_image)
        		size = 1073741824L / 2
        		fake_image.size = Mock(return_value = 1073741824L)
        		fake_image.resize = Mock(return_value = None)
        		self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL)
        		
        		size = 2 * 1073741824L
        		self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY)
        		rbd.Image = Mock(side_effect = rbd.ImageNotFound("%s image not found!" %self.img))
        		self.assertEqual(self.resize(self.img, size), RBD_COMMON.CODE_IMAGE_NOT_FOUND)
		

```

#### 3.6 连续mock

在rbd_api文件中有一个OpRados类的内容如下：

```python
#!/usr/bin/python
import rados

class OpRados:
	 def __init__(self):
	 	 self.cluster = rados.Rados(conffile=rconf['conffile'])
	 	 self.cluster.connect()
	 
	 def __del__(self):
	 	 self.cluster.shutdown()
	 
	 def lists(self):
	 	 return util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET, "", self.cluster.list_pools())

```

为该类写单元测试，具体代码如下：

```python
#!/usr/bin/python
import rados
import unittest
from mock import Mock
class TestOpRados(unittest.TestCase):
	def setUp(self)：
		fake_Rados = Mock()
		fake_Rados.connect = Mock(return_value = None)
		fake_Rados.shutdown = Mock(return_value = None)
		fake_Rados.list_pools = Mock(return_value = ["sqh", "sqh1"])
		# 注意：此处要使得rados.Rados()调用返回fake_Rados.
		# 如果写成rados.Rados = fake_Rados,只能使得self.cluster重新生成一个Mock对象
		# 无法有效的控制为fake_Rados所添加的属性。
		rados.Rados = Mock(return_value = fake_Rados)
		self.opRados = OpRados()
		
	def tearDown(self):
		fake_Rados = None
		self.opRados = None
	
	def test_list(self):
		return_list = ["sqh", "sqh1"]
		self.assertEqual(self.opRados.lists(), util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET,  "", return_list))

```

## 三.全栈web开发框架（高级测试扩展）

Django--->全栈开发框架

mtv的模式：m数据、t模版(html\css等)、v视图

flask------> 轻量级的框架

pyecharts--->可视化框架，内部提供了很多实现图形可视化的方法，详细方法参考：https://pyecharts.org/#/zh-cn/quickstart

# 第十四章 接口测试维度

## 一.阐述接口测试维度

接口测试的维度：

1.字段为空的验证

2.字段的边界值

3.字段的类型验证

4.基于业务的接口测试

如果公司内部对接口规范或者对接口不去做太多的要求的时候，忽略2、3

2019年工程效率：   	-->测试

- 更快--->接口测试
- 更好的产品质量---->自动化测试技术的手段，提高测试效率，那么我们人就有更多的时间来思考产品质量管理的这个部分。 

## 二.参数如何写更加高效

函数：

1.减少重复性代码

2.提供程序的扩展性

3.提高程序的维护性

实例：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
# '''
# 三目运算和递归的简单实现,输出i = 5的时候的结果
# '''
# def diGui(i=0):
#     i = i + 1
#     return ("{0}大于等于5".format(i)) if i>=5 else diGui(i)
# print(diGui())


dict1 = {'first':False,"pn":1,"kd":"自动化测试"}

def sendParam(pn=None,kd=None):
    data = dict1
    data["pn"] = pn
    data["kd"] = kd
    return data

def test_001():
    '''测试pn为空'''
    sendParam(kd="自动化测试")

def test_002():
    '''测试kd为空'''
    sendParam(pn=2)

def test_003():
    '''测试pn、kd都为空'''
    sendParam()

def test_004():
    '''测试pn的数据类型为字符型'''
    sendParam(pn="2")

```

# 第十五章 flask-restful

Django：全栈web框架

Flask：轻量级的web框架

## 一.flask-restful的概述：

- 什么是Restful
  - 超文本传输协议（http）属于请求和响应协议第七层（应用程序层），此曾于应用程序本身交互。HTTP被设计为客户端（用户代理）用于从服务器请求资源，这些资源可以是HTML文件或任何其他内容，如JSON、XML或媒体文件。这些资源请求由网络统一的资源定位器标示（URL）。Rest没有严格的标准，而是规定了一套对通信的约束，定义一种可以通过多种方式实现的方法。
- flask-restful是什么
  - `restful api`是用于在前端与后台进行通信的一套规范。使用这个规范可以让前后端开发变得更加轻松，
- restful安装
  - pip3 install flask
  - pip3 install flask-restful
  - pip3 install flask-httpauth
- flask-restful的简单API编写

{"status":0,"msg":"","data":""}

## 二.Restful接口测试维度案例应用

### 配置路由进行接口测试

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

from flask import Flask,make_response,jsonify
from flask_restful import  Resource,Api,reqparse

'''实例化Flask这个类'''
app = Flask(__name__)

'''调用flask Restful'''
api = Api(app=app)

'''配置index路由器'''
@app.route('/index')
def index():
    return jsonify({'status':0,'msg':'success','datas':{'userid':1003,'name':'shenqiang','age':'18'}})

'''配置login路由器'''
class LoginView(Resource):
    def get(self):
        return jsonify({'status':0,'msg':'success','datas':{}})

    def post(self):
        '''简单的数据约束和校验'''
        parser = reqparse.RequestParser()
        parser.add_argument('username',type=str,help='您的用户参数不能为空',required=True)
        parser.add_argument('password',type=str)
        parser.add_argument('age',type=int,help='您的年龄必须为整型')
        return jsonify(parser.parse_args())

'''添加请求地址：包含API，视图的路由地址'''
api.add_resource(LoginView,'/login',endpoint='login')

if __name__ == '__main__':
    app.run(debug=True)
```

### 配置基本鉴权进行测试

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang

from flask import Flask,make_response,jsonify
from flask_restful import  Resource,Api,reqparse
from flask_httpauth import HTTPBasicAuth

'''实例化Flask这个类'''
app = Flask(__name__)
'''调用flask Restful'''
api = Api(app=app)
'''调用鉴权'''
auth = HTTPBasicAuth()
'''解决jsonify中文显示乱码问题'''
app.config['JSON_AS_ASCII']=False
app.config['DEBUG']=True

'''输入账号密码认证，否者报错提示请认证'''
@auth.get_password
def get_password(username):
    if username == 'shenqiang':
        return 'admin'

@auth.error_handler
def authorized():
    return make_response(jsonify({'msg':'你好，请认证'}),401)

'''页面报错404的友好提示'''
@app.errorhandler(404)
def notFound(error):
    '''函数必须添加：error'''
    return make_response(jsonify({'error':'this page is not found'}),404)

'''页面报错405的友好提示'''
@app.errorhandler(405)
def notFound(error):
    '''函数必须添加：error'''
    return make_response(jsonify({'error':'该请求方法错误'}),405)

'''配置index路由器'''
'''添加登录鉴权资源'''
@app.route('/index')
@auth.login_required
def index():
    return jsonify({'status':0,'msg':'success','datas':{'userid':1003,'name':'shenqiang','age':'18'}})

if __name__ == '__main__':
    app.run(debug=True)
```

## 三.【Restful】Restful中案例实战

Rest提供以下指导约束：

客户端和服务器之间关注点分离：客户端和服务器应该能够独立发展或改变，只要API不改变。

无状态：处理请求所谓的任何信息都存储在请求本身或客户端。

| 请求方法 | 请求地址                             | 业务场景            |
| -------- | ------------------------------------ | ------------------- |
| GET      | http://localhost:5000/api/v1/books   | 获取所有图书信息    |
| POST     | http://localhost:5000/api/v1/books   | 添加图书信息        |
| GET      | http://localhost:5000/api/v1/books/1 | 获取ID为1的图书信息 |
| PUT      | http://localhost:5000/api/v1/books/1 | 修改ID为1的图书信息 |
| DELETE   | http://localhost:5000/api/v1/books/1 | 删除ID为1的图书信息 |

#### 代码改造前：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
from flask import Flask,make_response,jsonify,abort,request
from flask_restful import Api,Resource
from flask_httpauth import HTTPBasicAuth

'''实例化Flask、Api、HTTPBasicAuth'''
app = Flask(__name__)
api = Api(app=app)
auth = HTTPBasicAuth()
'''解决jsonify中文显示乱码问题'''
app.config['JSON_AS_ASCII']=False
app.config['DEBUG']=True

'''鉴权和异常验证'''

@auth.get_password
def get_password(name):
    if name == "bingo-shen":
        return 'shenqiang'

@auth.error_handler
def authentication():
    return make_response(jsonify({'msg':'请认证'}),401)

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'msg':'this is page not found'}))

'''图书管理系统'''
books=[
    {'id':1,'author':'bingo','name':'自动化测试','done':True},
    {'id':2,'author':'bingo','name':'自动化测试','done':True}
]

@app.route('/v1/api/books',methods=['GET'])
def get_books():
    return jsonify(books)

@app.route('/v1/api/books',methods=['POST'])
def create_books():
    if not request.json:
        abort(400)
    else:
        book = {
            'id':books[-1]['id'] + 1,
            'author': request.json.get('author'),
            'name':request.json.get('name'),
            'done':False
        }
        books.append(book)
        return jsonify({'msg':'create success'},201)

@app.route('/v1/api/books/<int:book_id>',methods=['GET'])
def get_book(book_id):
    book = list(filter(lambda t:t['id']==book_id,books))
    if len(book)==0:
        abort(404)
    else:
        return jsonify({'status':0,'msg':'success','data':book})

@app.route('/v1/api/books/<int:book_id>',methods=['DELETE'])
def delete_book(book_id):
    book = list(filter(lambda t:t['id']==book_id,books))
    if len(book)==0:
        abort(404)
    else:
        books.remove(book[0])
        return jsonify({'status':'1001','msg':'书籍的信息已经删除'})

@app.route('/v1/api/books/<int:book_id>',methods=['PUT'])
def put_book(book_id):
    book = list(filter(lambda t: t['id'] == book_id, books))
    if len(book)==0:
        abort(404)
    elif not  request.json:
        abort(400)
    elif 'author' not in request.json and 'name' not in request.json:
        abort(400)
    elif 'done' not in request.json and type(request.json['done']) is not bool:
        abort(400)
    else:
        book[0]['author'] = request.json.get('author',book[0]['author'])
        book[0]['name'] = request.json.get('name', book[0]['name'])
        book[0]['done'] = request.json.get('done', book[0]['done'])
        return jsonify({'statues':1002,'msg':'更新成功','data':book})

if __name__ == '__main__':
    app.run(debug=True)
```

#### 调用类方法改造后

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author : shenqiang
from flask import Flask,make_response,jsonify,abort,request
from flask_restful import Api,Resource
from flask_httpauth import HTTPBasicAuth

'''实例化Flask、Api、HTTPBasicAuth'''
app = Flask(__name__)
api = Api(app=app)
auth = HTTPBasicAuth()
'''解决jsonify中文显示乱码问题'''
app.config['JSON_AS_ASCII']=False
app.config['DEBUG']=True

'''鉴权和异常验证'''

@auth.get_password
def get_password(name):
    if name == "bingo-shen":
        return 'shenqiang'

@auth.error_handler
def authentication():
    return make_response(jsonify({'msg':'请认证'}),401)

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'msg':'this is page not found'}))

'''图书管理系统'''
books=[
    {'id':1,'author':'bingo','name':'自动化测试','done':True},
    {'id':2,'author':'bingo','name':'自动化测试','done':True}
]

class Books(Resource):
    '''类方法中使用鉴权'''
    decorators =[auth.login_required]

    def get(self):
        return jsonify({'status':0,'msg':'success','data':books})

    def post(self):
        if not request.json:
            return jsonify({'status':1001,'msg':'您返回的数据类型不是json格式的，请检查，谢谢！'})
        else:
            book = {
                'id': books[-1]['id'] + 1,
                'author': request.json.get('author'),
                'name': request.json.get('name'),
                'done': False
            }
            books.append(book)
            return jsonify({'status':1002,'msg':'书籍信息添加成功','data':books})

class Book(Resource):
    decorators = [auth.login_required]

    def get(self,book_id):
        book = list(filter(lambda t: t['id'] == book_id, books))
        if len(book) == 0:
            return jsonify({'status':1003,'msg':'很抱歉，你查询的书籍的信息不存在！'})
        else:
            return jsonify({'status': 0, 'msg': 'success', 'data': book})

    def put(self,book_id):
        book = list(filter(lambda t: t['id'] == book_id, books))
        if len(book) == 0:
            return jsonify({'status':1002,'msg':'很抱歉，你查询的书籍的信息不存在！'})
        elif not request.json:
            return jsonify({'status':1001,'msg':'您返回的数据类型不是json格式的，请检查，谢谢！'})
        elif 'author' not in request.json:
            return jsonify({'status': 1004, 'msg': '请求参数author不是json格式的'})
        elif 'name' not in request.json:
            return jsonify({'status': 1005, 'msg': '请求参数name不是json格式的'})
        elif 'done' not in request.json:
            return jsonify({'status': 1006, 'msg': '请求参数done不是json格式的'})
        elif type(request.json['done']) is not bool:
            return jsonify({'status': 1007, 'msg': '请求参数done不是bool类型的'})
        else:
            book[0]['author'] = request.json.get('author', book[0]['author'])
            book[0]['name'] = request.json.get('name', book[0]['name'])
            book[0]['done'] = request.json.get('done', book[0]['done'])
            return jsonify({'statues': 1008, 'msg': '更新成功', 'data': book})

    def delete(self,book_id):
        book = list(filter(lambda t: t['id'] == book_id, books))
        if len(book) == 0:
            return jsonify({'status': 1003, 'msg': '很抱歉，你查询的书籍的信息不存在！'})
        else:
            books.remove(book[0])
            return jsonify({'status':1009,'msg':'书籍的信息已经删除'})


api.add_resource(Books,'/v1/api/books')
api.add_resource(Book,'/v1/api/books/<int:book_id>')

if __name__ == '__main__':
    app.run(debug=True)

```

注意⚠️：推荐使用：

用户管理模块

用户添加：POST

用户查询：GET

用户修改：POST

用户删除：POST

# 第十六章 微服务架构

## 一.微服务与测试概述

###  1.什么是微服务

微服务是一种架构模式，它倡导将单体应用程序划分成一组小的服务，服务之间相互协调，相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信进制相互沟通。（基于HTTP协议是RESTFUL API）每个服务围绕具体的业务构建，并且能够独立部署到生产环境中。



从微服务的概念中可以得出这么几个结论：

1.微服务是将单体的应用程序分成N个小的服务，这些服务之间相互协作和相互调用

2.每一个微服务都是一个独立的进程

3.微服务采用的是轻量级的通信机制，主要是基于HTTP协议的RESTFUL API

4.每个微服务都围着具体的业务构建，并且独立部署

5.微服务与数据库之间不是绝对的，可能N个微服务使用一个数据库实例，也可能一个微服务使用一个数据库的实例。

### 2.微服务的通信

1.同步通信

2.异步通信

### 3.微服务的优点

1、易于维护，可以更快的开始开发

2、易于拓展，轻松的对某个组建进行拓展

3、技术多样性，技术选型比较自由

4、故障隔离，某一个微服务不应该导致整个系统停机

5、更高的组织支持，适合小型团队

6、独立部署，在部署的时候而不影响其他系统的微服务

### 4.微服务的缺点

1、分布式的特点，导致跟踪或者调试更加困难

2、更多的组件需要维护

3、很难在服务与事务之间实现强有力的一致性

### 5.微服务给测试带来的挑战

1、技术的挑战 ---> 需要了解微服务的通信和MQ

2、颠覆对传统的测试金字塔模型的认知（会影响到团队的组织效率--->康威定律）

3、随着CI和CD的发展，如何把自动化测试技术结合起来，做到测试的高效率

4、业务逻辑和流程的颠覆（客户端和服务端的边界越来越模糊）

应同场景：API开放平台：赋能 服务 多层封装

### 6.基于微服务的测试模型

![image-20191215221031093](/Users/apple/Library/Application Support/typora-user-images/image-20191215221031093.png)

在测试金字塔模型中:

#### 单元测试

是最底层的测试，单元测试的目的是验证(Class)是否可正常工作，主要 验证(Class)的方法是否符合预期的结果。

#### 集成测试

在微服务架构中,集成测试的目的是 验证服务与其他服务是否可正常的交互。集成测试的策略:

集成测试的策略是测试每个服务的适配器,和适配器支持类。

#### 契约测试

契约测试的目的是验证服务之间的交互目的, 和是否遵守了服务之间的约束。在契约测试中,需要了解测试消费者与测试生产者,确保 生产者与消费者在API是一致的，也就是说 验证客户端与服务端HTTP的请求和HTTP 的响应，主要应用于测试微服务的API网关 和对应的微服务。契约测试会使用到Spring Cloud Contact和pact。

契约测试 = 测试左移 + mock + 接口测试（CI）

详细参考：https://zhuanlan.zhihu.com/p/58400043

注意⚠️：因为契约测试在实际测试过程中，推行难度较大，仅仅适应于微服务，而且需要写Mock和去除Mock，比较难以进行，契约测试的实际的产出和集成测试的产出可能会存在部分差异，所以除了部分大厂和能力比较出众的测试开发、自动化测试，基本中小厂不会进行契约测试。

#### 组件测试

组件测试位于集成测试与端到端测试的中间，组件测试的目的是单独验证服务的行为，使
用模拟组件的行为的桩代替服务的依赖。

![image-20191215223830160](/Users/apple/Library/Application Support/typora-user-images/image-20191215223830160.png)

#### 端到端测试

端到端的测试是验证整个应用程序,端到端测试比较耗时，而且缓慢。 端到端的测试需要运行所有的应用 程序(所有涉及到的组件测试)。端 到端的测试主要是面向业务的测试,可以使用如WebDriver测试框架来 完成。

注意⚠️：区分单元测试、集成测试、契约测试、组件测试、端到端测试之间的区别

### 7.微服务的实例（中台、重点！！）

![image-20191214103134932](/Users/apple/Library/Application Support/typora-user-images/image-20191214103134932.png)



![image-20191214103216578](/Users/apple/Library/Application Support/typora-user-images/image-20191214103216578.png)

![image-20191214103338080](/Users/apple/Library/Application Support/typora-user-images/image-20191214103338080.png)

### 8.微服务带来的组织架构调整

![image-20191214153450725](/Users/apple/Library/Application Support/typora-user-images/image-20191214153450725.png)

![image-20191216123731916](/Users/apple/Library/Application Support/typora-user-images/image-20191216123731916.png)

## 二.单体架构应用模式

### 什么是单体架构应用模式：

不会带来太大的运营成本，但是只有一个庞大的数据库，单一的应用程序包含所有层的接口。比如客户端UI包含了HTML等，和服务端的应用程序，服务端应用程序处理HTTP的请求，使用服务类处理业务逻辑，从数据库中查询和更新数据，与其他系统的交互通常是HTML/JSON/XML格式的返回响应，在这样的架构模式中，服务端应用程序需要支持各种不同的客户端，如桌面浏览器，移动端浏览器和移动端的应用程序。

### 单体架构的业务实例（适应小型团队）

客户购买书籍单一架构模式：

业务：接收客户的订单，验证订购的书籍，地点的可用性，和订购书籍发送给客户。技术层次：前端和后端服务（账户服务-->验证客户，图书服务-->检查书籍的可用性，订单服务-->下订单和支持，物流服务-->发货跟踪）。如果开发语言是Java，就可以使war的方式，使用tomcat进行部署，web应用程序处理来自所有的HTTP的请求，流程具体为：客户端--> Apache/Nginx --> tomcat -->后端程序，下面展示应用程序体系架构设计图：

![image-20191214160455961](/Users/apple/Library/Application Support/typora-user-images/image-20191214160455961.png)

在如上图的架构模式中，如果需要引入新的功能模块，需要更改现有的代码，然后重新进行部署，这中间涉及到两个概念：个人生产力和团队生产力。在devops的观念中，认为所有的开发在主分支开发更加高效，而且也有具体的实践可以证明这件事，但是很难让程序员改变现有的观念，所以都在分支开发，合并，然后带来各种极其低下的工作方式。

服务端应用程序主要包含如下的组件：

1.基于HTTP的应用层的轻量级的通信方式，数据格式一般是JOSN/XML

2.业务逻辑：依据业务操作吧业务逻辑写入到对应的服务中

3.数据访问：数据访问对象负责访问数据库逻辑

4.应用程序即成：该组件负责即成，通过消息传递过着REST API与其他外部服务一起使用

### 单体应用程序的架构的好处

1.开发简单：如JAVA语言，使用主流的IDE和JAVA语言就可以了

2.易于测试：全部功能在一个组件中，轻松的使用如selenium工具实现端到端的测试

3.易于部署：轻松的打包成war文件部署到服务器中

4.易于拓展：复制组件轻松的实现部署到多个终端，并且实现负载均衡的设置

### 单体架构的局限性：

1.大型的代码库，比较难维护，所有的组件代码都在一起

2.应用程序庞大而复杂，很难快速的理解和进行正确的修改

3.不同模块容易冲突，架构很难拓展

4.技术很难改变，一旦改变，影响整体的应用程序

5.开发流程更加倾向于瀑布流的模式

## 三.微服务架构模式

### 什么是微服务架构模式

在微服务中，所有的服务都是松耦合的，共享其服务，并且可以独立的部署。微服务架构是指一种软件开发方法，其中大型软件应用程序分为几个可以独立部署的服务。这些服务规模下，模块化，遵循软件的单一责任原则发展，每项服务都可以相互通信同步，使用HTTP或者REST，或使用AMQ或Kafka异步。每个service包含自己的数据库。微服务架构背后的基本思想是拆分将您的整体应用程序升级为一组较小的互连服务。

### 基于微服务的架构实例图

![image-20191214164850238](/Users/apple/Library/Application Support/typora-user-images/image-20191214164850238.png)

在微服务中，每个模块都有自己的依赖，而不依赖其他的服务，服务器端应用程序必须处理来自各种客户端的请求。应用程序进行通信使用这个API，API网管负责负载均衡的处理，和提供缓存和访问控制，API的监控。

![image-20191214213202405](/Users/apple/Library/Application Support/typora-user-images/image-20191214213202405.png)

### 微服务的通行方式：

通信：轻量级的通信方式，HTTP Rest

数据格式：Json  Xml

服务端接口需要兼容多个不同版本的客户端：客户端有很多版本，服务只有一个

1.同步通信

(HTTP REST 	gRPC)

2.异步通信(回调:例如支付后钱在银行被扣了，但是应用提示支付失败)

(AMQP)

进程间的交互方式：

1.一对一，一对多

2.同步通信或者异步通信



以购买图书为例，说明微服务的同步通信：

![image-20191215122104697](/Users/apple/Library/Application Support/typora-user-images/image-20191215122104697.png)

![image-20191215122156841](/Users/apple/Library/Application Support/typora-user-images/image-20191215122156841.png)

##### 契约测试（实例：OPEN API）：

1.有100老用户没有加密

2.要求新用户对接的时候需要加密

接口在路由设置的时候，设置两个不同的路由版本

例如：

http://www.ceshi.com/v1

http://www.ceshi.com/v2

对应的接口自动化测试需要覆盖到这两个场景

#### 同步请求响应：

一对一：

1.客户端请求服务端，服务端响应恢复客户端请求/响应，期间可能存在超时，网络异常，进程的队列等待，会导致堵塞，

2.强耦合，python中有第三方库：pyhystrix

微服务雪崩容错处理框架，参考：https://blog.csdn.net/crave_shy/article/details/81321600

- pyhystrix的功能
  - 连接和读取超时
  - 连接失败时重试
  - 请求头添加唯一信息：x-request-id

![image-20191214224933587](/Users/apple/Library/Application Support/typora-user-images/image-20191214224933587.png)

3.单向请求

服务发现机制URL（对于云服务来说是难点）

#### 异步请求响应：

一对多：

1.客户端发送异步的请求，客户端不知道服务端的存在，消息端收到和护短的请求后，最终会被f服务端感兴趣的服务器回应。

2.发布&&订阅（kafka）

详细参考： https://blog.csdn.net/burpee/article/details/80017246

![image-20191214211847115](/Users/apple/Library/Application Support/typora-user-images/image-20191214211847115.png)

![image-20191214211917033](/Users/apple/Library/Application Support/typora-user-images/image-20191214211917033.png)

微服务